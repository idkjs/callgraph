(******************************************************************************)
(*   Copyright (C) 2014-2015 THALES Communication & Security                  *)
(*   All Rights Reserved                                                      *)
(*   European IST STANCE project (2011-2015)                                  *)
(*   author: Hugues Balp                                                      *)
(*                                                                            *)
(* This file completes json files generated by Callers with "extcallers" members *)
(******************************************************************************)

exception Callee_Function_Neither_Declared_Nor_Defined

class function_callers_json_parser (callee_json_filepath:string) = object(self)

  val callee_file_path : string = callee_json_filepath

  (* Check whether the callee function is well declared in the file or raise an error otherwise *)
  (* precondition: the callee function is not defined in the file *)
  (* exception: Callee_Function_Neither_Declared_Nor_Defined *)
  method callee_file_check_fct_decl (file:Callers_t.file) (callee_sign:string) : unit =

    let fct_decl = Callers.file_get_declared_function file callee_sign in
    (match fct_decl with
     | Some _ -> Printf.printf "the callee function \"%s\" is well declared in file \"%s\" as expected !\n" callee_sign file.file;
     | None ->
        (
          Printf.printf "EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE\n";
          Printf.printf "the callee function \"%s\" is neither declared nor defined in file \"%s\" as expected !\n" callee_sign file.file;
          Printf.printf "EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE\n";
          raise Callee_Function_Neither_Declared_Nor_Defined
        )
    )

  (* Check whether the callee function is well defined in the file or raise an error otherwise *)
  (* precondition: the callee function is not delared in the file *)
  (* exception: Callee_Function_Neither_Declared_Nor_Defined *)
  method callee_file_check_fct_def (file:Callers_t.file) (callee_sign:string) : unit =

    let fct_def = Callers.file_get_defined_function file callee_sign in
    (match fct_def with
     | Some _ -> Printf.printf "the callee function \"%s\" is well defined in file \"%s\" as expected !\n" callee_sign file.file;
     | None ->
        (
          Printf.printf "EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE\n";
          Printf.printf "the callee function \"%s\" is neither declared nor defined in file \"%s\" as expected !\n" callee_sign file.file;
          Printf.printf "EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE\n";
          raise Callee_Function_Neither_Declared_Nor_Defined
        )
    )

  (* method add_extcaller_to_file_fct_defs (extcaller:Callers_t.extfct) (fct_call_sign:string) (file:Callers_t.file) : Callers_t.fct_def list = *)

  (*   Printf.printf "add_extcallers.add_extcaller_to_file_fct_defs:BEGIN extcaller=%s file=%s\n" extcaller.sign file.file; *)

  (*   let fct_defs : Callers_t.fct_def list = *)

  (*     (match file.defined with *)

  (*      | None -> *)
  (*         ( *)
  (*           Printf.printf "WARNING: The callee function \"%s\" is not defined in the file \"%s\"\n" *)
  (*                         extcaller.sign file.file; *)
  (*           self#callee_file_check_fct_decl file fct_call_sign; *)
  (*           [] *)
  (*         ) *)

  (*      | Some fcts -> *)

  (*         List.map *)
  (*           ( *)
  (*             fun (fct:Callers_t.fct_def) -> *)

  (*             let new_fct:Callers_t.fct_def = *)

  (*               (\* Check whether the function is the callee one *\) *)
  (*               if (String.compare fct.sign fct_call_sign == 0) then *)
  (*                 ( *)
  (*                   let callee = fct in *)

  (*                   (\* Check whether the extcaller is already present in extcallers list *\) *)
  (*                   Printf.printf "Check whether the extcaller \"%s\" is already present in extcallers list of callee function \"%s\"\n" *)
  (*                                 extcaller.sign callee.sign; *)

  (*                   (\* Parses the list of external callers *\) *)
  (*                   let new_callee:Callers_t.fct_def = *)

  (*                     (match callee.extcallers with *)

  (*                      | None -> *)
  (*                         ( *)
  (*                           (\* Add the extcaller if not present *\) *)
  (*                           Printf.printf "It is not present, so "; *)
  (*                           self#add_extcaller_to_fct_def extcaller fct *)
  (*                         ) *)

  (*                      | Some extcallers -> *)
  (*                         ( *)
  (*                           (\* Look for the extcaller "extcaller.sign" *\) *)
  (*                           Printf.printf "Parse the external callers of callee function \"%s\" defined in file \"%s\"...\n" callee.sign file.file; *)
  (*                           try *)
  (*                             ( *)
  (*                               let extcaller = *)
  (*                                 List.find *)
  (*                                   ( *)
  (*                                     fun (f:Callers_t.extfct) -> *)
  (*                                     Printf.printf "extcaller: sign=\"%s\", decl=%s, def=%s\n" f.sign f.decl, f.def; *)
  (*                                     String.compare extcaller.sign f.sign == 0 *)
  (*                                   ) *)
  (*                                   extcallers *)
  (*                               in *)
  (*                               Printf.printf "The extcaller \"%s\" is already present in the definition of callee function \"%s\", so there is nothing to edit.\n" *)
  (*                                             fct_call_sign callee.sign; *)
  (*                               fct *)
  (*                             ) *)
  (*                           with *)
  (*                             Not_found -> *)
  (*                             ( *)
  (*                               (\* Add the extcaller if not present *\) *)
  (*                               Printf.printf "It is not present, so "; *)
  (*                               self#add_extcaller_to_fct_def extcaller callee *)
  (*                             ) *)
  (*                         ) *)
  (*                     ) *)
  (*                   in *)
  (*                   new_callee *)
  (*                 ) *)
  (*               else *)
  (*                 fct *)
  (*             in *)
  (*             new_fct *)
  (*           ) *)
  (*           fcts *)
  (*     ) *)
  (*   in *)
  (*   Printf.printf "add_extcallers.add_extcaller_to_file_fct_defs:END extcaller=%s file=%s\n" extcaller.sign file.file; *)
  (*   fct_defs *)

  (* method add_extcaller_to_fct_def (extcaller:Callers_t.extfct) (fct:Callers_t.fct_def) : Callers_t.fct_def = *)

  (*   Printf.printf "add_extcallers.add_extcaller_to_fct_def:BEGIN: add the extcaller \"%s\" to the extcallers list of function definition \"%s\"...\n" extcaller.sign fct.sign; *)

  (*   let new_extcallers = *)

  (*     (match fct.extcallers with *)
  (*      | None -> extcaller::[] *)
  (*      | Some extcallers -> extcaller::extcallers *)
  (*     ) *)
  (*   in *)

  (*   let updated_fct:Callers_t.fct_def = *)
  (*     { *)
  (*       (\* eClass = Config.get_type_fct_def(); *\) *)
  (*       sign = fct.sign; *)
  (*       line = fct.line; *)
  (*       decl = fct.decl; *)
  (*       virtuality = fct.virtuality; *)
  (*       locallers = fct.locallers; *)
  (*       locallees = fct.locallees; *)
  (*       extcallers = Some new_extcallers; *)
  (*       extcallees = fct.extcallees; *)
  (*       builtins = fct.builtins; *)
  (*     } *)
  (*   in *)
  (*   updated_fct *)

  method add_extcaller_to_file_fct_decls (extcaller:Callers_t.extfctdef) (fct_call_sign:string) (file:Callers_t.file) : Callers_t.fct_decl list =

    Printf.printf "add_extcallers.add_extcaller_to_file_fct_decls:BEGIN extcaller=%s file=%s\n" extcaller.sign file.file;

    let fct_decls : Callers_t.fct_decl list =

      (match file.declared with

       | None ->
          (
            Printf.printf "WARNING: the called function \"%s\" is not declared in the file \"%s\"\n"
                          fct_call_sign file.file;
            self#callee_file_check_fct_def file fct_call_sign;
            []
          )

       | Some fcts ->

          List.map
            (
              fun (fct:Callers_t.fct_decl) ->

              let new_fct:Callers_t.fct_decl =

                (* Check whether the function is the callee one *)
                if (String.compare fct.sign fct_call_sign == 0) then
                  (
                    let callee = fct in

                    (* Check whether the extcaller is already present in extcallers list *)
                    Printf.printf "Check whether the extcaller \"%s\" is already present in extcallers list of callee function \"%s\"\n"
                                  extcaller.sign callee.sign;

                    (* Parses the list of external callers *)
                    let new_callee:Callers_t.fct_decl =

                      (match callee.extcallers with

                       | None ->
                          (
                            (* Add the extcaller if not present *)
                            Printf.printf "It is not present, so ";
                            self#add_extcaller_to_fct_decl extcaller fct
                          )

                       | Some extcallers ->
                          (
                            (* Look for the extcaller "extcaller.sign" *)
                            Printf.printf "Parse the external callers of callee function \"%s\" declared in file \"%s\"...\n" callee.sign file.file;
                            try
                              (
                                let extcaller =
                                  List.find
                                    (
                                      fun (f:Callers_t.extfctdef) ->
                                      Printf.printf "extcaller: sign=\"%s\", def=%s, mangled=%s\n" f.sign f.def f.mangled;
                                      String.compare extcaller.sign f.sign == 0
                                    )
                                    extcallers
                                in
                                Printf.printf "The extcaller \"%s\" is already present in the declaration of callee function \"%s\", so there is nothing to edit.\n"
                                              fct_call_sign callee.sign;
                                fct
                              )
                            with
                              Not_found ->
                              (
                                (* Add the extcaller if not present *)
                                Printf.printf "It is not present, so ";
                                self#add_extcaller_to_fct_decl extcaller callee
                              )
                          )
                      )
                    in
                    new_callee
                  )
                else
                  fct
              in
              new_fct
            )
            fcts
      )
    in
    Printf.printf "add_extcallers.add_extcaller_to_file_fct_decls:END extcaller=%s file=%s\n" extcaller.sign file.file;
    fct_decls

  method add_extcaller_to_fct_decl (extcaller:Callers_t.extfctdef) (fct:Callers_t.fct_decl) : Callers_t.fct_decl =

    Printf.printf "add_extcallers.add_extcaller_to_fct_decl:BEGIN: add the extcaller \"%s\" to the extcallers list of function declaration \"%s\"...\n" extcaller.sign fct.sign;

    let new_extcallers =

      (match fct.extcallers with
       | None -> extcaller::[]
       | Some extcallers -> extcaller::extcallers
      )
    in

    let updated_fct:Callers_t.fct_decl =
      {
	sign = fct.sign;
	line = fct.line;
        mangled = fct.mangled;
	virtuality = fct.virtuality;
        redeclarations = fct.redeclarations;
        definitions = fct.definitions;
        redeclared = fct.redeclared;
	locallers = fct.locallers;
	extcallers = Some new_extcallers;
        recordName = fct.recordName;
        recordPath = fct.recordPath;
        threads = fct.threads;
      }
    in
    updated_fct

  method add_extcaller_to_file (extcaller:Callers_t.extfctdef) (callee_sign:string) (callee_jsonfilepath:string) : unit =

    Printf.printf "add_extcallers.add_extcaller_to_file:BEGIN: Try to add extcaller \"%s\" to callee function \"%s\" declared in file \"%s\"...\n" extcaller.sign callee_sign callee_jsonfilepath;
    (* Parse the json file of the callee function *)
    let dirpath : string = Common.read_before_last '/' callee_jsonfilepath in
    let filename : string = Common.read_after_last '/' 1 callee_jsonfilepath in
    let jsoname_file = String.concat "" [ dirpath; "/"; filename; ".file.callers.gen.json" ] in
    (* let jsoname_file = String.concat "" [ Common.rootdir_prefix; dirpath; "/"; filename; ".file.callers.gen.json" ] in *)
    (* Use the atdgen Yojson parser *)
    let content = Common.read_json_file jsoname_file in
    (match content with
     | None -> ()
     | Some content ->
     (
        (* Printf.printf "Read callee file \"%s\" content is:\n %s: \n" filename content; *)
        (* Printf.printf "atdgen parsed json file is :\n"; *)
        let file : Callers_t.file = Callers_j.file_of_string content in

        (* Look for the callee function among all functions declared in the callee file *)
        let new_declared_functions : Callers_t.fct_decl list =
          self#add_extcaller_to_file_fct_decls extcaller callee_sign file
        in

        (* (\* Look for the callee function among all functions defined in the callee file *\) *)
        (* let new_defined_functions : Callers_t.fct_def list = *)
        (*   self#add_extcaller_to_file_fct_defs extcaller callee_sign file *)
        (* in *)

        let new_file : Callers_t.file =
          {
            file = file.file;
            kind = file.kind;
            path = file.path;
            namespaces = file.namespaces;
            records = file.records;
            threads = file.threads;
            declared = Some new_declared_functions;
            defined = file.defined;
            (* defined = Some new_defined_functions; *)
          }
        in
        Callers.print_callers_file new_file jsoname_file
      )
    );
    Printf.printf "add_extcallers.add_extcaller_to_file:END: Try to add extcaller \"%s\" to callee function \"%s\" declared in file \"%s\"...\n" extcaller.sign callee_sign callee_jsonfilepath

  method parse_current_file (*fct_sign:string*) (json_filepath:string) : (* Callers_t.fct_def option *) unit =

    (* Use the atdgen Yojson parser *)
    let dirpath : string = Common.read_before_last '/' json_filepath in
    let filename : string = Common.read_after_last '/' 1 json_filepath in
    let jsoname_file = String.concat "" [ dirpath; "/"; filename; ".file.callers.gen.json" ] in
    let content = Common.read_json_file jsoname_file in

    (match content with
     | None -> ()
     | Some content ->
       (
        (* Printf.printf "Read caller file \"%s\" content is:\n %s: \n" filename content; *)
        (* Printf.printf "atdgen parsed json file is :\n"; *)
        let file : Callers_t.file = Callers_j.file_of_string content in

        (* Parse the json functions contained in the current file *)
        (match file.defined with
         | None -> ()
         | Some fcts ->

            (* parse extcallees of each function *)
            List.iter
              (
                fun (fct:Callers_t.fct_def) ->

                (* Parses external callees *)
                (match fct.extcallees with
                 | None -> ()
                 | Some extcallees ->
                    Printf.printf "Parse external callees of function \"%s\" defined in file \"%s\"...\n" fct.sign file.file;
                    List.iter
                      (
                        fun (f:Callers_t.extfctdecl) ->

                        Printf.printf "extcallee: sign=\"%s\", decl=%s, mangled=%s\n" f.sign f.decl f.mangled;
                        let extcaller : Callers_t.extfctdef =
                          {
                            sign = fct.sign;
                            def =
                              (match file.path with
                              | None -> raise Common.Missing_File_Path
                              | Some path -> Printf.sprintf "%s/%s:%d" path file.file fct.line
                              );
                            mangled = fct.mangled;
                          }
                        in
                        let decl_file : string =
                          (match f.decl with
                          | "unknownExtFctDecl" ->
                            (
                              Printf.printf "EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE\n";
                              Printf.printf "add_extcallers.ml::ERROR::incomplete caller file json file:\"%s\"\n" json_filepath;
                              Printf.printf "You need first to complete extcallees definitions by launching the callers++ clang plugin\n";
                              Printf.printf "EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE\n";
                              raise Common.Usage_Error
                            )
                          | "builtinFunctionDecl" ->
                            (
                              Printf.printf "IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII\n";
                              Printf.printf "add_extcallers.ml::WARNING::the builtin function \"%s\" is called by function \"%s\" defined in json file:\"%s\"\n" f.sign fct.sign json_filepath;
                              Printf.printf "IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII\n";
                              "unknownBuiltinFunctionLocation"
                            )
                          | "unlinkedExtCallee" ->
                            (
                              Printf.printf "WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW\n";
                              Printf.printf "add_extcallers.ml::WARNING::incomplete caller file json file:\"%s\"\n" json_filepath;
                              Printf.printf "The link edition may have failed due to an incomplete defined symbols json file.\n";
                              Printf.printf "The unlinked symbol below is probably part of an external library:\n";
                              Printf.printf "caller symb: %s\n" fct.sign;
                              Printf.printf "unlinked extcallee symb: %s\n" f.sign;
                              Printf.printf "WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW\n";
                              "unknownLocation"
                            )
                          | unsupportedCase ->
                            (
                              let loc : string list = Str.split_delim (Str.regexp ":") f.decl in
                              (match loc with
                              | [ file; _ ] ->  file
                              | _ ->
                                 Printf.printf "EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE\n";
                                 Printf.printf "add_extcallers.ml::ERROR::Unsupported Case: %s" unsupportedCase;
                                 Printf.printf "EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE\n";
                                 raise Common.Unexpected_Case)
                            )
                          )
                        in
                        (
                          match decl_file with
                          | "unknownBuiltinFunctionLocation"
                          | "unknownLocation" -> ()
                          | _ -> self#add_extcaller_to_file extcaller f.sign decl_file
                        )
                      )
                      extcallees
                )
              )
              fcts
        )
      )
    )
end

(* Anonymous argument *)
let spec =
  let open Core.Std.Command.Spec in
  empty
  +> anon ("file_json" %: string)

(* Basic command *)
let command =
  Core.Std.Command.basic
    ~summary:"Parses function's extcallees from callers's generated json files"
    ~readme:(fun () -> "More detailed information")
    spec
    (
      fun file_json () ->

      let parser = new function_callers_json_parser file_json in

      parser#parse_current_file file_json;
    )

(* Running Basic Commands *)
let () =
  Core.Std.Command.run ~version:"1.0" ~build_info:"RWO" command

(* Local Variables: *)
(* mode: tuareg *)
(* compile-command: "ocamlbuild -use-ocamlfind -package atdgen -package core -package batteries -tag thread add_extcallers.native" *)
(* End: *)
