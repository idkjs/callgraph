(******************************************************************************)
(*   Copyright (C) 2014-2015 THALES Communication & Security                  *)
(*   All Rights Reserved                                                      *)
(*   European IST STANCE project (2011-2015)                                  *)
(*   author: Hugues Balp                                                      *)
(*                                                                            *)
(* This file completes json files generated by Callers with "inherited" classes *)
(******************************************************************************)

module Classes = Map.Make(String);;

class class_parents_json_parser (class_json_filepath:string) = object(self)

  val class_file_path : string = class_json_filepath

  method add_inherited_to_class (inherited:Callers_t.inheritance) (record:Callers_t.record) : Callers_t.record =

    Printf.printf "add the inherited class \"%s\" to the inherited list of class \"%s\"...\n" inherited.record record.name;

    let new_inherited =

      (match record.inherited with

       | None -> inherited::[]

       | Some inherited_classes -> inherited::inherited_classes
      )
    in

    let updated_record:Callers_t.record =
      {
	(* eClass = Config.get_type_record(); *)
	(* name = record.name; *)
	name = record.name;
	kind = record.kind;
	debut = record.debut;
	fin = record.fin;
	inherited = Some new_inherited;
	inherits = record.inherits;
        methods = record.methods;
      }
    in
    updated_record

  method add_inherited_to_file (inherited:Callers_t.inheritance) (base_class:string) (class_jsonfilepath:string) : unit =

    Printf.printf "Try to add inherited \"%s\" to base class \"%s\" defined in file \"%s\"...\n" inherited.record base_class class_jsonfilepath;
    (* Parse the json file of the base class *)
    let dirpath : string = Common.read_before_last '/' class_jsonfilepath in
    let filename : string = Common.read_after_last '/' 1 class_jsonfilepath in
    let jsoname_file = String.concat "" [ dirpath; "/"; filename; ".file.callers.gen.json" ] in
    (* Use the atdgen Yojson parser *)
    let content = Common.read_json_file jsoname_file in
    (match content with
     | None -> ()
     | Some content ->
        (
          (* Printf.printf "Read class file \"%s\" content is:\n %s: \n" filename content; *)
          (* Printf.printf "atdgen parsed json file is :\n"; *)
          let file : Callers_t.file = Callers_j.file_of_string content in
          (* print_endline (Callers_j.string_of_file file); *)

          (* Look for the base class among all classes defined in the class file *)
          let new_defined_classes : Callers_t.record list =

            (match file.records with

             | None ->
	        (
	          (* Abnormal case. At least the base class should normally be defined in the class file. *)
	          Printf.printf "Suspect case. The base class \"%s\" should normally be defined in the class file \"%s\" ! However it might have been ignored by callers analysis of the class file"
			        base_class class_jsonfilepath;
	          []
	        )

             | Some records ->

	        List.map
  	          (
  	            fun (record:Callers_t.record) ->

	            let new_record:Callers_t.record =

                      (* Check whether the class is the class one *)
	              if (String.compare record.name base_class == 0) then
		        (
		          let cclass = record in

		          (* Check whether the inherited class is already present in the list of inherited classes *)
		          Printf.printf "Check whether the inherited \"%s\" is already present in inherited list of base class \"%s\"\n"
				        inherited.record base_class;

		          (* Parses the list of inherited classes *)
		          let new_class:Callers_t.record =

		            (match cclass.inherited with

		             | None ->
			        (
			          (* Add the inherited if not present *)
			          Printf.printf "It is not present, so ";
			          self#add_inherited_to_class inherited record
			        )

		             | Some children ->
			        (
			          (* Look for the inherited class "inherited.record" *)
			          Printf.printf "Parse the base classes of class \"%s\" defined in file \"%s\"...\n" cclass.name file.file;
			          try
			            (
			              let inherited =
				        List.find
  				          (
  				            fun (i:Callers_t.inheritance) ->
				            Printf.printf "inherited: record=\"%s\", file=%s\n" i.record i.file;
				            String.compare inherited.record i.record == 0
				          )
				          children
			              in
			              Printf.printf "The inherited class \"%s\" is already present in the definition of base class \"%s\", so there is nothing to edit.\n"
					            inherited.record base_class;
			              record
			            )
			          with
			            Not_found ->
			            (
			              (* Add the inherited if not present *)
			              Printf.printf "It is not present, so ";
			              self#add_inherited_to_class inherited cclass
			            )
			        )
		            )
		          in
		          new_class
		        )
	              else
		        record
	            in
	            new_record
	          )
	          records
            )
          in

          (* WARNING: in cases where the base class is never used locally as a caller one,
        it might not yet been present in the input class json file; therefore we have to add it once
        we know it is called from outside of the file. *)

          (* Check whether the base class is well present in the class file. *)
          try
            (
	      let _ (*already_existing_class_record*) =
	        List.find
	          (
  	            fun (record:Callers_t.record) -> String.compare record.name base_class == 0
	          )
	          new_defined_classes
	      in

	      (* The base class does already exists in the class file. *)

	      let new_file : Callers_t.file =
	        {
	          file = file.file;
                  kind = file.kind;
	          path = file.path;
	          namespaces = file.namespaces;
	          records = Some new_defined_classes;
                  threads = file.threads;
	          declared = file.declared;
	          defined = file.defined;
	        }
	      in
	      Callers.print_callers_file new_file	jsoname_file
            )
          with
            Not_found ->
            (
	      Printf.printf "The base class \"%s\" is not yet present in file \"%s\" as expected; so we add it to satisfy the inheritance relationship\n"
		            base_class file.file;

	      let newly_added_class_record : Callers_t.record =
	        {
	          (* eClass = Config.get_type_record(); *)
	          (* name = base_class; *)
	          name = base_class;
	          kind = "class";
	          debut = -1;
                  fin = -2;
	          inherited = Some [ inherited ];
	          inherits = None;
                  methods = None;
	        }
	      in

	      (* Now the caller class will be added to the class file. *)
	      let new_file : Callers_t.file =
	        {
	          file = file.file;
                  kind = file.kind;
	          path = file.path;
	          namespaces = file.namespaces;
	          records = Some (newly_added_class_record::new_defined_classes);
                  threads = file.threads;
	          declared = file.declared;
	          defined = file.defined;
	        }
	      in
	      Callers.print_callers_file new_file jsoname_file
            )
        )
    )

  method parse_current_file (*record_sign:string*) (json_filepath:string) : (* Callers_t.record option *) unit =

    (* Use the atdgen Yojson parser *)
    let dirpath : string = Common.read_before_last '/' json_filepath in
    let filename : string = Common.read_after_last '/' 1 json_filepath in
    let jsoname_file = String.concat "" [ dirpath; "/"; filename; ".file.callers.gen.json" ] in
    let content = Common.read_json_file jsoname_file in
    (match content with
     | None -> ()
     | Some content ->
       (
         (* Printf.printf "Read caller file \"%s\" content is:\n %s: \n" filename content; *)
         (* Printf.printf "atdgen parsed json file is :\n"; *)
         let file : Callers_t.file = Callers_j.file_of_string content in

         (* Parse the json classes contained in the current file *)
         (match file.records with
          | None -> ()
          | Some records ->

             (* parse inherits of each class *)
	     List.iter
  	       (
  	         fun (record:Callers_t.record) ->

	         (* Parses inherited classes *)
	         (match record.inherits with
	          | None -> ()
	          | Some inherits ->
		     Printf.printf "Parse inherited classes of class \"%s\" defined in file \"%s\"...\n" record.name file.file;
		     List.iter
		       (
		         fun (i:Callers_t.inheritance) ->

		         Printf.printf "inherits: record=\"%s\", file=%s\n" i.record i.file;
		         let inherited : Callers_t.inheritance =
		           {
			     record = record.name;
			     file =
			       (match file.path with
			        | None -> raise Common.Missing_File_Path
			        | Some path -> Printf.sprintf "%s/%s" path file.file
			       );
                             debut = record.debut;
                             fin = record.fin;
		           }
		         in
		         let def_file : string =
		           (match i.file with
		            | "unknownInheritanceDef" ->
			       (
			         Printf.printf "EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE\n";
			         Printf.printf "add_inherited.ml::ERROR::incomplete caller file json file:\"%s\"\n" json_filepath;
			         Printf.printf "You need first to complete inherits definitions by executing the add_inherits ocaml program\n";
			         Printf.printf "EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE\n";
			         raise Common.Usage_Error
			       )
		            | "unlinkedInherits" ->
			       (
			         Printf.printf "WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW\n";
			         Printf.printf "add_inherited.ml::WARNING::incomplete caller file json file:\"%s\"\n" json_filepath;
			         Printf.printf "The link edition may have failed due to an incomplee defined symbols json file.\n";
			         Printf.printf "The unlinked symbol below is probably part of an external library:\n";
			         Printf.printf "caller symb: %s\n" record.name;
			         Printf.printf "unlinked inherits class: %s\n" i.record;
			         Printf.printf "WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW\n";
			         "unknownLocation"
			       )
		            | _ -> i.file
			   )
		         in
		         (
		           match def_file with
		           | "unknownBuiltinClassLocation"
		           | "unknownLocation" -> ()
		           | _ -> self#add_inherited_to_file inherited i.record def_file
		         )
		       )
		       inherits
	         )
	       )
	       records
         )
       )
    )
end

(* Anonymous argument *)
let spec =
  let open Core.Std.Command.Spec in
  empty
  +> anon ("file_json" %: string)

(* Basic command *)
let command =
  Core.Std.Command.basic
    ~summary:"Parses parent classes from callers's generated classes in json files"
    ~readme:(fun () -> "More detailed information")
    spec
    (
      fun file_json () ->

      let parser = new class_parents_json_parser file_json in

      parser#parse_current_file file_json;
    )

(* Running Basic Commands *)
let () =
  Core.Std.Command.run ~version:"1.0" ~build_info:"RWO" command

(* Local Variables: *)
(* mode: tuareg *)
(* compile-command: "ocamlbuild -use-ocamlfind -package atdgen -package core -package batteries -tag thread add_inherited.native" *)
(* End: *)
