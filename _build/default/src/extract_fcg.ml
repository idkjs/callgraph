(******************************************************************************)
(*   Copyright (C) 2014-2015 THALES Communication & Security                  *)
(*   All Rights Reserved                                                      *)
(*   European IST STANCE project (2011-2015)                                  *)
(*   author: Hugues Balp                                                      *)
(*                                                                            *)
(* This file generates dot graphs from json files generated by Callers        *)
(* and linked together thanks to some other OCAML backends                    *)
(******************************************************************************)

module Definitions = Map.Make(String);;
module Declarations = Map.Make(String);;
module CallersMap = Map.Make(String);;
module CalleesMap = Map.Make(String);;
module CallsMap = Map.Make(String);;

type direction = Up | Down | UpAndDown;;

let string_of_dir (dir:direction) : string =

  (match dir with
   | Up -> "callers"
   | Down -> "callees"
   | UpAndDown -> "c2c"
  )

class function_callers_json_parser
	(callee_id:string)
	(callee_signature:string)
	(callee_json_filepath:string)
	(other:string list option)
	(* (root_directory:string)  *)
  = object(self)

  inherit Function_callgraph.function_callgraph

  val callee_id : string = callee_id

  val callee_sign : string = callee_signature

  val callee_file_path : string = callee_json_filepath

  val show_files : bool =

    (match other with
    | None -> false
    | Some args ->

      let show_files : string =
        try
          List.find
            (
              fun arg ->
                (match arg with
                | "files" -> true
                | _ -> false
                )
            )
            args
        with
          Not_found -> "none"
      in
      (match show_files with
      | "files" -> true
      | "none"
      | _ -> false
      )
    )

  (* Function callers graph *)
  val mutable gfct_callers : Graph_func.G.t = Graph_func.G.empty

  (* Function callees graph *)
  val mutable gfct_callees : Graph_func.G.t = Graph_func.G.empty

  (* Function caller to callee  graph *)
  val mutable gfct_c2c : Graph_func.G.t = Graph_func.G.empty

  val mutable callees_table = CalleesMap.empty
  val mutable callers_table = CalleesMap.empty

  val mutable callees_calls_table = CallsMap.empty
  val mutable callers_calls_table = CallsMap.empty

  (* Tables to ensure function's decalarations and definitions are visited only once *)
  val mutable parsed_defined_functions = Definitions.empty
  val mutable parsed_declared_functions = Declarations.empty

  (* Add a dot vertex in the dot graph for the input function *)
  method dot_graph_add_function (dir:direction) (fct_sign:string) (fct_virtuality:string option) (fct_file:string) : Graph_func.function_decl =

    let fct : Graph_func.function_decl = self#dump_fct fct_sign fct_virtuality fct_file in
    (match dir with
     | Up ->        ( gfct_callers <- Graph_func.G.add_vertex gfct_callers fct )
     | Down ->      ( gfct_callees <- Graph_func.G.add_vertex gfct_callees fct )
     | UpAndDown -> ( gfct_c2c     <- Graph_func.G.add_vertex gfct_c2c fct )
    );
    fct

  (* Add a node in the callgraph for the input function *)
  method callgraph_add_declared_function (fct:Callers_t.fct_decl) (fct_filepath:string) :
           (Callgraph_t.fonction_decl * Callgraph_t.file) =

    Printf.printf "extract_fcg.callgraph_add_declared_function:BEGIN: fct.sign=%s filepath=%s\n" fct.sign fct_filepath;

    (try
        (
          let file = self#get_file fct_filepath in
          let file =
            (match file with
             | None -> self#dir_get_file_or_add_new fct_filepath
             | Some file -> file
            )
          in
          (
            let is_defined = Callers.function_decl_is_defined fct in
            let does_already_exist = self#get_fct_decl file fct.sign in
            let fct_decl =
              (match does_already_exist with
               | None ->
                  (
                    let virtuality =
                      (match fct.virtuality with
                       | None
                       | Some "no" -> None
                       | Some _ -> fct.virtuality
                      )
                    in
                    let parameters : Callgraph_t.fct_param list option =
                      (match fct.params with
                         | None -> None
                         | Some params ->
                            Some
                              (
                                List.map
                                  (
                                    fun (p : Callers_t.fct_param) ->
                                    (
                                      Printf.printf "extract_fcg.callgraph_add_declared_function:INFO: param=%s, kind=%s\n" p.name p.kind;
                                      let param : Callgraph_t.fct_param =
                                        {
                                          name = p.name;
                                          kind = p.kind;
                                        }
                                      in
                                      param
                                    )
                                  )
                                  params
                              )
                      )
                    in
                    let new_fct_decl : Callgraph_t.fonction_decl =
                      {
                        sign = fct.sign;
                        mangled = fct.mangled;
                        virtuality = virtuality;
                        params = parameters;
                        isdef = is_defined;
                        virtdecls = None;
                        localdef = None;
                        locallers = None;
                        extdefs = None;
                        extcallers = None;
                        virtcallerdecls = None;
                        virtcallerdefs = None;
                        nspc = fct.nspc;
                        record = fct.recordName;
                        threads = fct.threads;
                      }
                    in
                    self#add_fct_decls file [new_fct_decl];
                    (* (\* Add a new nspc when needed *\) *)
                    (* (match fct.nspc with *)
                    (*  | None -> () *)
                    (*  | Some nspc -> *)
                    (*     ( *)
                    (*       let nsp = self#file_get_namespace_or_add_new fct_filepath nspc in *)
                    (*       (match fct.recordName with *)
                    (*        | None -> () *)
                    (*        | Some record -> *)
                    (*           ( *)
                    (*             self#namespace_add_record nsp record *)
                    (*           ) *)
                    (*       ) *)
                    (*     ) *)
                    (* ); *)
                    (* Add a new record when needed *)
                    (match fct.recordName with
                     | None -> ()
                     | Some record ->
                        (
                          let rc = self#file_get_record_or_add_new fct_filepath record in
                          self#record_add_method_decl rc new_fct_decl.mangled
                        )
                    );
                    (new_fct_decl, file)
                  )
               | Some already_existing_fct_decl ->
                  (
                    Printf.printf "extract_fcg.callgraph_add_declared_function:INFO: get the already existing declared function \"%s\" !\n" fct.sign;
                    (* Add a new record when needed *)
                    (match fct.recordName with
                     | None -> ()
                     | Some record ->
                        (
                          let rc = self#file_get_record_or_add_new fct_filepath record in
                          self#record_add_method_decl rc already_existing_fct_decl.mangled;
                          (* (\* Add a new nspc when needed *\) *)
                          (* (match fct.nspc with *)
                          (*  | None -> () *)
                          (*  | Some nspc -> *)
                          (*     ( *)
                          (*       let nsp = self#file_get_namespace_or_add_new fct_filepath nspc in *)
                          (*       self#namespace_add_record nsp record *)
                          (*     ) *)
                          (* ) *)
                        )
                    );
                    (already_existing_fct_decl, file)
                  )
              )
            in
            Printf.printf "extract_fcg.callgraph_add_declared_function:END fct.sign=%s filepath=%s\n" fct.sign fct_filepath;
            fct_decl
          )
        )
      with
        Common.Usage_Error ->
        (
          let rdir = self#get_fcg_rootdir in
          Printf.printf "DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD\n";
          Printf.printf "extract_fcg.callgraph_add_declared_function:DEBUG: Usage_Error: rdir=%s, fct_filepath=%s\n" rdir.path fct_filepath;
          Printf.printf "DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD\n";
          Common.notify_error Common.Internal_Error
        )
    )

  (* Add a node in the callgraph for the input function *)
  method callgraph_add_defined_function (fct:Callers_t.fct_def) (fct_filepath:string) :
           Callgraph_t.fonction_def * Callgraph_t.file =

    Printf.printf "extract_fcg.callgraph_add_defined_function:BEGIN: fct_sign=%s filepath=%s\n" fct.sign fct_filepath;
    (try
        (
          let file = self#get_file fct_filepath in
          let file =
            (match file with
             | None -> self#dir_get_file_or_add_new fct_filepath
             | Some file -> file
            )
          in
          let does_already_exist = self#get_fct_def file fct.sign in
          let fct_def =
            (match does_already_exist with
             | None ->
                (
                  let virtuality =
                    (match fct.virtuality with
                     | None
                     | Some "no" -> None
                     | Some _ -> fct.virtuality
                    )
                  in
                  let new_fct_def : Callgraph_t.fonction_def =
                    {
                      sign = fct.sign;
                      virtuality = fct.virtuality;
                      mangled = fct.mangled;
                      localdecl = None; (* localdecl; *)
                      locallees = None;
                      extdecls = None;
                      extcallees = None;
                      virtcallees = None;
                      nspc = fct.nspc;
                      record = fct.recordName;
                      threads = fct.threads;
                    }
                  in
                  self#add_fct_defs file [new_fct_def];
                  (* Add a new record when needed *)
                  (match fct.recordName with
                  | None -> ()
                  | Some record ->
                     (match Callers.fct_def_get_file_decl fct_filepath fct with
                      | None -> ()
                      | Some path ->
                         (
                           let rc = self#file_get_record_or_add_new path record in
                           self#record_add_method_def rc new_fct_def.mangled;
                          (* Add a new nspc when needed *)
                          (* (match fct.nspc with *)
                          (*  | None -> () *)
                          (*  | Some nspc -> *)
                          (*     ( *)
                          (*       let nsp = self#file_get_namespace_or_add_new fct_filepath nspc in *)
                          (*       self#namespace_add_record nsp record *)
                          (*     ) *)
                          (* ) *)
                         )
                     )
                  );
                  (* Add new threads when needed *)
                  (match fct.threads with
                  | None -> ()
                  | Some threads ->
                     (
                       List.iter
                       (
                         fun (thr_id:string) ->
                         (
                           let thr = self#file_get_thread_or_add_new fct_filepath thr_id in
                           let vroutine = self#parse_declared_function_and_definitions thr.routine_sign thr.routine_file fct.sign None in ()
                         )
                       )
                       threads
                     )
                  );
                  new_fct_def
                )
             | Some already_existing_fct_def ->
                (
                  Printf.printf "extract_fcg.callgraph_add_defined_function:INFO: get the already existing defined function \"%s\" !\n" fct.sign;
                  (* Add a new record when needed *)
                  (match fct.recordName with
                  | None -> ()
                  | Some record ->
                     (
                       let record_filepath =
                         (match Callers.fct_def_get_file_decl fct_filepath fct with
                          | None -> Common.notify_error Common.Unexpected_Case2
                          | Some path -> path
                         )
                       in
                       let rc = self#file_get_record_or_add_new record_filepath record in
                       self#record_add_method_def rc already_existing_fct_def.mangled;
                       (* Add a new nspc when needed *)
                       (* (match fct.nspc with *)
                       (*  | None -> () *)
                       (*  | Some nspc -> *)
                       (*     ( *)
                       (*       let nsp = self#file_get_namespace_or_add_new fct_filepath nspc in *)
                       (*       self#namespace_add_record nsp record *)
                       (*     ) *)
                       (* ) *)
                     )
                  );
                  (* Add new threads when needed *)
                  (match fct.threads with
                  | None -> ()
                  | Some threads ->
                     (
                       List.iter
                       (
                         fun (thr_id:string) ->
                         (
                           let thr = self#file_get_thread_or_add_new fct_filepath thr_id in

                           let vroutine = self#parse_declared_function_and_definitions thr.routine_sign thr.routine_file fct.sign None in ()
	                   (* (match vroutine with *)
	                   (*  | None -> () (\* cycle probably detected *\) *)
	                   (*  | Some (cg_routine_decl, _) -> *)
                           (*     ( *)
		           (*     ) *)
                         )
                       )
                       threads
                     )
                  );
                  already_existing_fct_def
                )
            )
          in
          Printf.printf "extract_fcg.callgraph_add_defined_function:END: fct_sign=%s filepath=%s\n" fct.sign fct_filepath;
          (fct_def, file)
        )
      with
        Common.Usage_Error ->
        (
          let rdir = self#get_fcg_rootdir in
          Printf.printf "DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD\n";
          Printf.printf "extract_fcg.callgraph_add_defined_function:DEBUG: Usage_Error: rdir=%s, fct_filepath=%s\n" rdir.path fct_filepath;
          Printf.printf "DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD\n";
          Common.notify_error Common.Internal_Error
        )
    )

  method dump_fct (fct_sign:string) (fct_virtuality:string option) (fct_file:string) : Graph_func.function_decl =

    (* Replace all / by _ in the file path *)
    let fpath : string = Str.global_replace (Str.regexp "\\/") "_" fct_file in

    (* Replace all '.' by '_' in the file path *)
    let fpath : string = Str.global_replace (Str.regexp "\\.") "_" fpath in

    (* Replace all '-' by '_' in the file path *)
    let fpath : string = Str.global_replace (Str.regexp "\\-") "_" fpath in

    (* Replace all '+' by 'p' in the file path *)
    let fpath : string = Str.global_replace (Str.regexp "\\+") "p" fpath in

    let filename : string = Filename.basename fct_file in

    let file : Graph.Graphviz.DotAttributes.subgraph option =
      if show_files then
	Some
    	  {
    	    sg_name = fpath;
    	    sg_attributes = [ `Label filename ];
    	    (* sg_parent = Some class_memberdef_factory.file.sg_name; *)
    	    sg_parent = None;
    	  }
      else
	None
    in
    let virtuality =
      (match fct_virtuality with
       | None -> "no"
       | Some v -> v
      )
    in
    let v : Graph_func.function_decl =
      {
	id = fct_sign;
	name = fct_sign;
        virtuality = virtuality;
	file = file
      }
    in
    v

  method parse_declared_function (fct_def:string) : unit =

    parsed_declared_functions <- Definitions.add fct_def true parsed_declared_functions

  method parsed_declared_function (fct_def:string) : bool =

    try
      Definitions.find fct_def parsed_declared_functions
    with
      Not_found -> false

  method parse_defined_function (fct_def:string) : unit =

    parsed_defined_functions <- Definitions.add fct_def true parsed_defined_functions

  method parsed_defined_function (fct_def:string) : bool =

    try
      Definitions.find fct_def parsed_defined_functions
    with
      Not_found -> false

  method callees_register_function_call (call:string) : unit =

    Printf.printf "extract_fcg.callees_register_function_call:INFO: %s\n" call;

    callees_calls_table <- CallsMap.add call true callees_calls_table

  method callees_registered_as_function_call (call:string) : bool =

    let registered =
      try
        CallsMap.find call callees_calls_table
      with
        Not_found -> false
    in
    Printf.printf "extract_fcg.callees_registered_as_function_call:INFO: %s: %b\n" call registered;
    registered

  method callers_register_function_call (call:string) : unit =

    callers_calls_table <- CallsMap.add call true callers_calls_table

  method callers_registered_as_function_call (call:string) : bool =

    try
      CallsMap.find call callers_calls_table
    with
      Not_found -> false

  method register_function_callee (fct_sign:string) : unit =

    callees_table <- CalleesMap.add fct_sign true callees_table

  method registered_as_function_callee (fct_sign:string) : bool =

    try
      CalleesMap.find fct_sign callees_table
    with
      Not_found -> false

  method register_function_caller (fct_sign:string) : unit =

    callers_table <- CallersMap.add fct_sign true callers_table

  method registered_as_function_caller (fct_sign:string) : bool =

    try
      CallersMap.find fct_sign callers_table
    with
      Not_found -> false

  method parse_defined_function_and_callees (fct_sign:string) (fct_def_file:string)
         : (Callgraph_t.fonction_def * Graph_func.function_decl) option =

    Printf.printf "extract_fcg.parse_defined_function_and_callees:BEGIN fct_sign=%s fct_def_file=%s\n";

    let vcaller = self#dot_graph_add_function Down fct_sign None fct_def_file in

    (* Parse current function *)
    let c_fct_def = Callers.parse_defined_fct_in_file fct_sign fct_def_file in

    let called_fct : (Callgraph_t.fonction_def * Graph_func.function_decl) option =

      (match c_fct_def with
       | None ->
          (
            Printf.printf "WARNING: the function \"%s\" is not defined in file \"%s\" !\n" fct_sign fct_def_file;
            None
          )
       | Some c_fct_def ->
          (
            let (cg_fct_def, fc_file) = self#callgraph_add_defined_function c_fct_def fct_def_file in

            (* Parse local callees *)
            (match c_fct_def.locallees with
             | None -> ()
             | Some locallees ->
	        Printf.printf "Parse local callees...\n";
	        List.iter
	          ( fun (locallee:string) ->
	            Printf.printf "visit locallee: %s...\n" locallee;
	            let vcallee = self#parse_declared_function_and_definitions locallee fct_def_file fct_sign (Some vcaller) in
	            (match vcallee with
	             | None -> () (* cycle probably detected *)
	             | Some (cg_fcallee_decl, vcallee) ->
                        (
		          gfct_callees <- Graph_func.G.add_edge_e gfct_callees (Graph_func.G.E.create vcaller "internal" vcallee);
                          let virtuality = Callers.fct_virtuality_option_to_string cg_fcallee_decl.virtuality in

                          let fcg_callee : Callgraph_t.fct_ref =
                          {
                            sign = cg_fcallee_decl.sign;
                            virtuality = virtuality;
                            mangled = cg_fcallee_decl.mangled;
                          }
                          in
                          self#add_fct_locallee cg_fct_def fcg_callee
                        )
	            )
	          )
	          locallees
            );

            (* Parse remote callees *)
            (match c_fct_def.extcallees with
             | None -> ()
             | Some extcallees ->
	        Printf.printf "Parse remote callees...\n";
	        List.iter
	          ( fun (f:Callers_t.extfctdecl) ->
                    let fdecl_file = Common.read_before_first ':' f.decl in
	            (match fdecl_file with
	             | "unknownExtFctDecl" ->
		        (
		          Printf.printf "wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww\n";
		          Printf.printf "WARNING: Unable to visit unknown extcallee declaration: %s\n" f.sign;
		          Printf.printf "caller sign is: %s\n" c_fct_def.sign;
		          Printf.printf "callee decl is: %s\n" fdecl_file;
		          Printf.printf "wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww\n";
		          let vcallee : Graph_func.function_decl = self#dump_fct f.sign None fdecl_file in
		          gfct_callees <- Graph_func.G.add_edge_e gfct_callees (Graph_func.G.E.create vcaller "external" vcallee)
		        )
	             | "unlinkedExtCalleeDecl" ->
		        (
		          Printf.printf "wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww\n";
		          Printf.printf "WARNING: Unable to visit unlinked extcallee declaration: %s\n" f.sign;
		          Printf.printf "caller sign is: %s\n" c_fct_def.sign;
		          Printf.printf "callee decl is: %s\n" fdecl_file;
		          Printf.printf "wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww\n";
		          let vcallee : Graph_func.function_decl = self#dump_fct f.sign None fdecl_file in
		          gfct_callees <- Graph_func.G.add_edge_e gfct_callees (Graph_func.G.E.create vcaller "external" vcallee)
		        )
	             | "builtinFunctionDecl" ->
		        (
		          let vcallee : Graph_func.function_decl = self#dump_fct f.sign None fdecl_file in
		          gfct_callees <- Graph_func.G.add_edge_e gfct_callees (Graph_func.G.E.create vcaller "external" vcallee)
 		        )
	             | _ -> (* Nominal case *)
		        (
		          let vcallee = self#parse_declared_function_and_definitions f.sign fdecl_file fct_sign (Some vcaller) in
		          (match vcallee with
		           (* | None -> Common.notify_error Common.Internal_Error *)
		           | None -> () (* cycle probably detected *)
		           | Some (cg_fct_decl, vcallee) ->
		              (
                                gfct_callees <- Graph_func.G.add_edge_e gfct_callees (Graph_func.G.E.create vcaller "cycle" vcallee);

                                let virtuality = Callers.fct_virtuality_option_to_string cg_fct_decl.virtuality in

                                Printf.printf "HBDBG_191: virtuality=%s\n" virtuality;

                                self#file_add_calls fc_file fct_def_file fdecl_file;

                                (* Add a calls dependency when needed between directories *)
                                let (fct_def_dirpath, _) = Batteries.String.rsplit fct_def_file "/" in
                                let (fct_decl_dirpath, _) = Batteries.String.rsplit fdecl_file "/" in

                                let fct_def_dir : Callgraph_t.dir = self#get_dir fct_def_dirpath in
                                let fct_decl_dir : Callgraph_t.dir = self#get_dir fct_decl_dirpath in

                                self#dir_check_dep fct_def_dir fct_decl_dir;

                                Printf.printf "HBDBG_2...\n";

                                let fcg_callee : Callgraph_t.extfct_ref =
                                  {
                                    sign = cg_fct_decl.sign;
                                    virtuality = virtuality;
                                    file = fdecl_file;
                                    mangled = cg_fct_decl.mangled;
                                  }
                                in

                                (match cg_fct_decl.virtuality with
                                 | None
                                 | Some "no" -> self#add_fct_extcallee cg_fct_def fcg_callee
                                 | _ -> self#add_fct_virtcallee cg_fct_def fcg_callee
                                )
                              )
		          )
		        )
	            )
	          )
	          extcallees
            );
            Some (cg_fct_def, vcaller)
          )
      )
    in
    (match called_fct with
    | None -> Printf.printf "extract_fcg.parse_defined_function_and_callees:RETURN: No defined function returned\n"
    | Some (f, _) -> Printf.printf "extract_fcg.parse_defined_function_and_callees:RETURN: returned defined function \"%s\"\n" fct_sign
    );
    Printf.printf "extract_fcg.parse_defined_function_and_callees:END fct_sign=%s fct_def_file=%s\n";
    called_fct

  method parse_declared_function_and_definitions (fct_decl_sign:string) (fct_decl_file:string)
					         (gcaller_sign:string) (gcaller_v:Graph_func.function_decl option)
	 : (Callgraph_t.fonction_decl * Graph_func.function_decl) option =

    let declared_fct_index = String.concat ":" [ fct_decl_sign; fct_decl_file; gcaller_sign ] in

    if self#parsed_declared_function declared_fct_index then
      (
	(* Printf.printf "DEBUG: parse_declared_function_and_definitions:INFO:ALREADY_PARSED_DECL: callee_sign=\"%s\" fct_decl_file=\"%s\" caller_sign=\"%s\"\n" fct_decl_sign fct_decl_file gcaller_sign; *)
	None
      )
    else
      (
	self#parse_declared_function declared_fct_index;

	Printf.printf "extract_fcg.parse_declared_function_and_definitions:BEGIN: callee_sign=\"%s\" fct_decl_file=\"%s\" caller_sign=\"%s\"\n" fct_decl_sign fct_decl_file gcaller_sign;

	(* Parse current function *)
	let fct : Callers_t.fct_decl option = Callers.parse_declared_fct_in_file fct_decl_sign fct_decl_file in

	(match fct with
	 | None ->
	    Printf.printf "extract_fcg.parse_declared_function_and_definitions:END:WARNING: no function found in file \"%s\" with signature=\"%s\" !\n"
			  fct_decl_file fct_decl_sign;
	    None

	 | Some fct ->
	    (
              let (fct_decl, fc_file) = self#callgraph_add_declared_function fct fct_decl_file in
              (* let fct_decl : Callgraph_t.fonction_def = Function_callgraph.FuncDecl (self#callgraph_add_declared_function fct fct_decl_file) in *)

              let vcaller = self#dot_graph_add_function Down fct.sign fct.virtuality fct_decl_file in

	      (* let vcaller : Graph_func.function_decl = self#dump_fct fct.sign fct_decl_file in *)
	      (* gfct_callees <- Graph_func.G.add_vertex gfct_callees vcaller; *)

	      let call : string = String.concat "" [ gcaller_sign; " -> "; fct_decl_sign ]
	      in

		(match fct.virtuality with
                 | None
		 | Some "no" -> Printf.printf "The function \"%s\" is not virtual\n" fct_decl_sign
		 | Some "declared" -> Printf.printf "The function \"%s\" is declared as virtual\n" fct_decl_sign
		 | Some "defined" -> Printf.printf "The function \"%s\" is defined as virtual\n" fct_decl_sign
		 | Some "pure" -> Printf.printf "The function \"%s\" is virtual pure\n" fct_decl_sign
		 | _ -> Common.notify_error Common.Unsupported_Virtuality_Keyword
		);

		(* Parse definitions *)
		(match fct.definitions with
		 | None -> ()
		 | Some definitions ->
		    Printf.printf "Parse definitions...\n";
		    List.iter
		      ( fun (f:string) ->
			Printf.printf "visit definition: %s...\n" f;
                        let fdef_file = Common.read_before_first ':' f in
			let fct_def_file : string =
                          (match fdef_file with
                           | "unlinkedDefinition" ->
                              (
                                Printf.printf "extract_fcg.function_callers_json_parser:LEAF: function \"%s\" is unlinked, so do not navigate through it\n" fct_decl_sign;
                                Common.notify_error Common.Internal_Error
                              )
			   | "local" ->
                              (
                                Printf.printf "visit local definition: %s in file %s\n" f fct_decl_file;
                                fct_decl_file
                              )
			   | fct_def_file ->
                              (
                                Printf.printf "visit external definition: %s in file %s\n" f fct_def_file;
                                fct_def_file
                              )
			   (* | _ -> *)
                           (*    ( *)
                           (*      Printf.printf "extract_fcg.function_callers_json_parser:unrecognized definition file \"%s\" for function \"%s\" \n" f fct_decl_sign; *)
                           (*      (\*Common.notify_error Common.Malformed_Reference_Fct_Def*\) *)
                           (*      Common.notify_error Common.Internal_Error *)
                           (*    ) *)
			  )
                        in
                        (
			  (* let vcallee = self#parse_defined_function_and_callees (fct_decl_sign) (file) (gcaller_sign) (Some vcaller) in *)
			  let vcallee = self#parse_defined_function_and_callees fct_decl_sign fct_def_file (*gcaller_sign*) (*gcaller_v*) in
			  (match vcallee with
			   | None -> () (* cycle probably detected *)
			   | Some (fcallee, vcallee) ->

                              let is_same_file : bool = (String.compare fct_decl_file fct_def_file == 0) in

                              (match is_same_file with
                               | true ->
                                  (
                                    self#add_fct_localdef fct_decl fcallee;
                                    self#add_fct_localdecl fcallee fct_decl;
                                  )
                               | false ->
                                  (
                                    self#file_add_calls fc_file fct_decl_file fct_def_file;
                                    self#add_fct_extdef fct_decl fcallee fct_def_file;
                                    self#add_fct_extdecl fcallee fct_decl fct_decl_file;
                                  )
                              );

			      (match gcaller_v with
			       | None ->
				  (
				    gfct_callees <- Graph_func.G.add_edge_e gfct_callees (Graph_func.G.E.create vcaller "cycle" vcallee)
				  )
			       | Some gcaller ->
				  (
				    if self#parsed_defined_function declared_fct_index then
				      (
				        Printf.printf "HBDBG: parse_declared_function_and_definitions:INFO:ALREADY_PARSED_DEF: callee_sign=\"%s\" fct_decl_file=\"%s\" caller_sign=\"%s\"\n" fct_decl_sign fct_def_file gcaller_sign
				      )
				    else
				      (
				        Printf.printf "HBDBG: parse_declared_function_and_definitions:INFO:PRINT_DEF: callee_sign=\"%s\" fct_decl_file=\"%s\" caller_sign=\"%s\"\n" fct_decl_sign fct_def_file gcaller_sign;
				        gfct_callees <- Graph_func.G.add_edge_e gfct_callees (Graph_func.G.E.create gcaller "external" vcallee)
				      )
				  )
			      )
			  )
		        )
                      )
		  definitions
	        );

		(* Parse redeclarations *)
		(match fct.redeclarations with
		 | None -> ()
		 | Some redeclarations ->
		    Printf.printf "Parse redeclarations...\n";
		    List.iter
		      ( fun (f:Callers_t.extfctdecl) ->
                        let fdecl_file = Common.read_before_first ':' f.decl in
			(match fdecl_file with
			 | "unknownExtFctDecl" ->
			    (
			      Printf.printf "wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww\n";
			      Printf.printf "WARNING: Unable to visit unknown redeclared function: %s\n" f.sign;
			      Printf.printf "caller sign is: %s\n" fct.sign;
			      Printf.printf "callee decl is: %s\n" fdecl_file;
			      Printf.printf "wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww\n";
			      let vcallee : Graph_func.function_decl = self#dump_fct f.sign None fdecl_file in
			      gfct_callees <- Graph_func.G.add_edge_e gfct_callees (Graph_func.G.E.create vcaller "external" vcallee)
			    )
			 | "unlinkedRedeclaredFunction" ->
			    (
			      Printf.printf "wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww\n";
			      Printf.printf "WARNING: Unable to visit unlinked redeclared function: %s\n" f.sign;
			      Printf.printf "caller sign is: %s\n" fct.sign;
			      Printf.printf "callee decl is: %s\n" fdecl_file;
			      Printf.printf "wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww\n";
			      let vcallee : Graph_func.function_decl = self#dump_fct f.sign None fdecl_file in
			      gfct_callees <- Graph_func.G.add_edge_e gfct_callees (Graph_func.G.E.create vcaller "external" vcallee)
			    )
			 | "builtinFunctionDecl" ->
			    (
			      let vcallee : Graph_func.function_decl = self#dump_fct f.sign None fdecl_file in
			      gfct_callees <- Graph_func.G.add_edge_e gfct_callees (Graph_func.G.E.create vcaller "external" vcallee)
 			    )
			 | _ ->
			    (
			      (* let vcallee = self#parse_declared_function_and_definitions (f.sign) (file) (fct_decl_sign) (Some vcaller) in *)
			      let vcallee = self#parse_declared_function_and_definitions f.sign fdecl_file gcaller_sign gcaller_v in
			      (match vcallee with
			       (* | None -> Common.notify_error Common.Internal_Error *)
			       | None -> () (* cycle probably detected *)
			       | Some (fcallee, vcallee) ->

                                  gfct_callees <- Graph_func.G.add_edge_e gfct_callees (Graph_func.G.E.create vcaller "internal" vcallee);
                                  Printf.printf "HBDBG_20\n";

                                  self#add_fct_virtdecl fct_decl fcallee;

                                  (* Add a virtual calls dependency when needed between records *)
                                  (match fct_decl.record with
                                   | None -> ()
                                   | Some fct_caller_rc ->
                                      (
                                        (match fcallee.record with
                                         | None -> ()
                                         | Some cg_fcallee_decl_rc ->
                                            (
                                              let cg_fct_caller_rc = self#file_get_record_or_add_new fct_decl_file fct_caller_rc in
                                              self#record_add_virtcalls cg_fct_caller_rc cg_fcallee_decl_rc;
                                              (* Add a new nspc when needed *)
                                              (* (match fcallee.nspc with *)
                                              (*  | None -> () *)
                                              (*  | Some nspc -> *)
                                              (*     ( *)
                                              (*       let nsp = self#file_get_namespace_or_add_new fct_decl_file nspc in *)
                                              (*       self#namespace_add_record nsp cg_fcallee_decl_rc *)
                                              (*     ) *)
                                              (* ) *)
                                            )
                                        )
                                      )
                                  )
			      )
			    )
			)
		      )
		      redeclarations
		);
	        Printf.printf "extract_fcg.parse_declared_function_and_definitions:END: callee_sign=\"%s\" fct_decl_file=\"%s\" caller_sign=\"%s\"\n" fct_decl_sign fct_decl_file gcaller_sign;
		Some (fct_decl, vcaller)
	      )
	    )
	)

  method parse_declared_function_and_callers (fct_sign:string) (fct_file:string)
         : (Callgraph_t.fonction_decl * Graph_func.function_decl) option =

    Printf.printf "extract_fcg.parse_declared_function_and_callers:BEGIN fct_sign=%s fct_file=%s\n";

    let vcallee = self#dot_graph_add_function Down fct_sign None fct_file in

    (* Parse current function *)
    let fct : Callers_t.fct_decl option = Callers.parse_declared_fct_in_file fct_sign fct_file in

    let called_fct : (Callgraph_t.fonction_decl * Graph_func.function_decl) option =

      (match fct with
       | None ->
          (
            Printf.printf "WARNING: the function \"%s\" is not declared in file \"%s\" !\n" fct_sign fct_file;
            None
          )
       | Some fct ->
          (
            let (fct_decl, fc_file) = self#callgraph_add_declared_function fct fct_file in

            (* Parse local callers *)
            (match fct.locallers with
             | None -> ()
             | Some locallers ->
	        Printf.printf "Parse local callers...\n";
	        List.iter
	          ( fun (f:string) ->
	            Printf.printf "visit locallee: %s...\n" f;
	            let vcaller = self#parse_defined_function_and_declaration f fct_file fct_sign (Some vcallee) in
	            (match vcaller with
	             | None -> () (* cycle probably detected *)
	             | Some (fcaller_def, vcaller) ->
                        (
		          gfct_callers <- Graph_func.G.add_edge_e gfct_callers (Graph_func.G.E.create vcaller "internal" vcallee);
                          Printf.printf "HBDBG_1\n";
                          let virtuality = Callers.fct_virtuality_option_to_string fcaller_def.virtuality in

                          let fcg_caller : Callgraph_t.fct_ref =
                          {
                            sign = fcaller_def.sign;
                            virtuality = virtuality;
                            mangled = fcaller_def.mangled;
                          }
                          in
                          self#add_fct_localler fct_decl fcg_caller;
                        )
	            )
	          )
	          locallers
            );

            (* Parse remote callers *)
            (match fct.extcallers with
             | None -> ()
             | Some extcallers ->
	        Printf.printf "Parse remote callers...\n";
	        List.iter
	          ( fun (extcaller:Callers_t.extfctdef) ->
                    let decl_file = Common.read_before_first ':' extcaller.def in
	            (match decl_file with
	             | "unknownExtFctDef"
	             | "unlinkedExtCallerDef"
	             | "builtinFunctionDef" ->
		        (
		          Printf.printf "EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE\n";
		          Printf.printf "ERROR: Unable to visit unknown extcaller definition: %s\n" extcaller.def;
		          Printf.printf "callee decl is: %s\n" fct.sign;
		          Printf.printf "EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE\n";
                          Common.notify_error Common.Unexpected_Case4
		        )
	             | _ ->
		        (
                          let vcaller = self#parse_defined_function_and_declaration extcaller.sign decl_file fct_sign (Some vcallee) in
                          (match vcaller with
                           (* | None -> Common.notify_error Common.Internal_Error *)
                           | None -> () (* cycle probably detected *)
                           | Some (vfct, vcaller) ->
                              (
                                gfct_callers <- Graph_func.G.add_edge_e gfct_callers (Graph_func.G.E.create vcaller "cycle" vcallee);

                                let virtuality = Callers.fct_virtuality_option_to_string vfct.virtuality in

                                Printf.printf "HBDBG_192: virtuality=%s\n" virtuality;

                                self#file_add_calls fc_file decl_file fct_file;

                                (* Add a calls dependency when needed between directories *)
                                let (fct_def_dirpath, _) = Batteries.String.rsplit fct_file "/" in
                                let (fct_decl_dirpath, _) = Batteries.String.rsplit decl_file "/" in
                                let fct_def_dir : Callgraph_t.dir = self#get_dir fct_def_dirpath in
                                let fct_decl_dir : Callgraph_t.dir = self#get_dir fct_decl_dirpath in
                                self#dir_check_dep fct_def_dir fct_decl_dir;

                                let fcg_caller : Callgraph_t.extfct_ref =
                                  {
                                    sign = vfct.sign;
                                    virtuality = virtuality;
                                    mangled = vfct.mangled;
                                    file = fct_file;
                                  }
                                in
                                (match vfct.virtuality with
                                 | None
                                 | Some "no" -> self#add_fct_extcaller fct_decl fcg_caller
                                 | Some "pure"
                                 | Some "declared" -> self#add_fct_virtcallerdecl fct_decl fcg_caller
                                 | Some "defined" -> self#add_fct_virtcallerdef fct_decl fcg_caller
                                 | _ -> Common.notify_error Common.Unsupported_Virtuality_Keyword
                                )
                              )
                          )
                        )
	            )
	          )
	          extcallers
            );

            (* Parse callers of the redeclared method *)
            (match fct.redeclared with
             | None -> ()
             | Some [redeclared] ->
                Printf.printf "Parse redeclared methods...\n";
	        Printf.printf "extract_fcg.parse_declared_function_and_callers:INFO: parse callers of the redeclared method %s...\n" redeclared.sign;
		(
                  let fct_redecl_file = Common.read_before_first ':' redeclared.decl in
                  (
		    let vcaller = self#parse_declared_function_and_callers redeclared.sign fct_redecl_file in
		    (match vcaller with
		     | None -> Common.notify_error Common.Unexpected_Case6
		     | Some (fcaller, vcaller) ->
                        (
                          if(String.compare fct_file fct_redecl_file != 0) then
                            (
                              self#file_add_calls fc_file fct_file fct_redecl_file
                            );

                          (* Add a virtual calls dependency when needed between records *)
                          (match fcaller.record with
                           | None -> ()
                           | Some fct_caller_rc ->
                              (
                                (match fct_decl.record with
                                 | None -> ()
                                 | Some fct_callee_rc ->
                                    (
                                      let cg_fct_caller_rc = self#file_get_record_or_add_new fct_redecl_file fct_caller_rc in
                                      self#record_add_virtcalls cg_fct_caller_rc fct_callee_rc;
                                    (* Add a new nspc when needed *)
                                    (* (match fct_decl.nspc with *)
                                    (*  | None -> () *)
                                    (*  | Some nspc -> *)
                                    (*     ( *)
                                    (*       let nsp = self#file_get_namespace_or_add_new fct_redecl_file nspc in *)
                                    (*       self#namespace_add_record nsp fct_callee_rc *)
                                    (*     ) *)
                                    (* ) *)
                                    )
                                )
                              )
                          );

                          let virtuality = Callers.fct_virtuality_option_to_string fct.virtuality in
                          let fcg_caller : Callgraph_t.extfct_ref =
                            {
                              sign = fcaller.sign;
                              mangled = fcaller.mangled;
                              virtuality = virtuality;
                              file = fct_redecl_file;
                            }
                          in
                          (match fcaller.virtuality with
                           | None
                           | Some "no" -> Common.notify_error Common.Unexpected_Case7
                           | Some "pure"
                           | Some "declared" -> self#add_fct_virtcallerdecl fct_decl fcg_caller
                           | Some "defined" -> self#add_fct_virtcallerdef fct_decl fcg_caller
                           | _ -> Common.notify_error Common.Unsupported_Virtuality_Keyword
                          )
                        )
                    )
                  )
                )
            );
            Some (fct_decl, vcallee)
          )
      )
    in
    (match called_fct with
    | None -> Printf.printf "extract_fcg.parse_declared_function_and_callers:RETURN: No declared function returned\n"
    | Some (f, _) -> Printf.printf "extract_fcg.parse_declared_function_and_callers:RETURN: returned declared function \"%s\"\n" fct_sign
    );
    Printf.printf "extract_fcg.parse_declared_function_and_callers:END fct_sign=%s fct_file=%s\n";
    called_fct

  method parse_defined_function_and_declaration (fct_sign:string) (fct_file:string)
					        (gcaller_sign:string) (gcaller_v:Graph_func.function_decl option)
	 : (Callgraph_t.fonction_def * Graph_func.function_decl) option =

    let defined_fct_index = String.concat ":" [ fct_sign; fct_file; gcaller_sign ] in

    if self#parsed_defined_function defined_fct_index then
      (
	(* Printf.printf "DEBUG: parse_defined_function_and_declaration:INFO:ALREADY_PARSED_DECL: callee_sign=\"%s\" fct_file=\"%s\" caller_sign=\"%s\"\n" fct_sign fct_file gcaller_sign; *)
	None
      )
    else
      (
	self#parse_defined_function defined_fct_index;

	Printf.printf "extract_fcg.parse_defined_function_and_declaration:BEGIN: callee_sign=\"%s\" fct_file=\"%s\" caller_sign=\"%s\"\n" fct_sign fct_file gcaller_sign;

	(* Parse current function *)
	let fct : Callers_t.fct_def option = Callers.parse_defined_fct_in_file fct_sign fct_file in

	(match fct with
	 | None ->
	    Printf.printf "extract_fcg.parse_defined_function_and_declaration:END:WARNING: no function found in file \"%s\" with signature=\"%s\" !\n"
			  fct_file fct_sign;
	    None

	 | Some fct ->
	    (
              let (fct_def, _) = self#callgraph_add_defined_function fct fct_file in
              (* let fct_def : Callgraph_t.fonction_decl = Function_callgraph.FuncDecl (self#callgraph_add_defined_function fct fct_file) in *)

              let vcallee = self#dot_graph_add_function Down fct.sign fct.virtuality fct_file in

	      (* let vcaller : Graph_func.function_decl = self#dump_fct fct.sign fct_file in *)
	      (* gfct_callers <- Graph_func.G.add_vertex gfct_callers vcaller; *)

	      let call : string = String.concat "" [ gcaller_sign; " -> "; fct_sign ]
	      in

	      (match fct.virtuality with
               | None
	       | Some "no" -> Printf.printf "The function \"%s\" is not virtual\n" fct_sign
	       | Some "defined" -> Printf.printf "The function \"%s\" is defined as virtual\n" fct_sign
	       | Some "declared" -> Printf.printf "The function \"%s\" is declared as virtual\n" fct_sign
	       | Some "pure" -> Printf.printf "The function \"%s\" is virtual pure\n" fct_sign
	       | _ -> Common.notify_error Common.Unsupported_Virtuality_Keyword
	      );

              (* Parse declaration *)
              (match fct.decl with
               | None -> ()
	       | Some declaration ->
		  (
		    Printf.printf "Parse declaration: %s...\n" declaration;
                    let fdecl_file = Common.read_before_first ':' declaration in
                    (
		      (* let vcallee = self#parse_declared_function_and_callers (fct_sign) (fdecl_file) (gcaller_sign) (Some vcaller) in *)
		      let vcaller = self#parse_declared_function_and_callers fct_sign fdecl_file (*gcaller_sign*) (*gcaller_v*) in
		      (match vcaller with
		       | None -> () (* cycle probably detected *)
		       | Some (fcaller, vcaller) ->

                          self#add_fct_localdecl fct_def fcaller;

			  (match gcaller_v with
			   | None ->
			      (
				gfct_callers <- Graph_func.G.add_edge_e gfct_callers (Graph_func.G.E.create vcaller "cycle" vcallee);
                                Printf.printf "HBDBG_3\n";
			      )
			   | Some gcaller ->
			      (
				if self#parsed_declared_function defined_fct_index then
				  (
				    Printf.printf "HBDBG: parse_defined_function_and_declaration:INFO:ALREADY_PARSED_DEF: callee_sign=\"%s\" fct_file=\"%s\" caller_sign=\"%s\"\n" fct_sign fdecl_file gcaller_sign
				  )
				else
				  (
				    Printf.printf "HBDBG: parse_defined_function_and_declaration:INFO:PRINT_DEF: callee_sign=\"%s\" fct_file=\"%s\" caller_sign=\"%s\"\n" fct_sign fdecl_file gcaller_sign;
				    gfct_callers <- Graph_func.G.add_edge_e gfct_callers (Graph_func.G.E.create gcaller "external" vcallee)
				  )
			      )
			  )
		      )
		    )
		  )
              );
	      Printf.printf "extract_fcg.parse_defined_function_and_declaration:END: callee_sign=\"%s\" fct_file=\"%s\" caller_sign=\"%s\"\n" fct_sign fct_file gcaller_sign;
	      Some (fct_def, vcallee)
	    )
	)
      )

  method output_function_callers (dot_filename:string) : unit =

    let file = open_out_bin dot_filename in
    Graph_func.Dot.output_graph file gfct_callers

  method output_function_callees (dot_filename:string) : unit =

    let file = open_out_bin dot_filename in
    Graph_func.Dot.output_graph file gfct_callees

  method output_function_c2c (dot_filename:string) : unit =

    let file = open_out_bin dot_filename in
    Graph_func.Dot.output_graph file gfct_c2c

end

(* Anonymous argument *)
let spec =
  let open Core.Std.Command.Spec in
  empty
  +> anon ("direction" %: string)
  +> anon ("fct1_file" %: string)
  +> anon ("fct1_id" %: string)
  +> anon ("fct1_sign" %: string)
  +> anon (maybe(sequence("other" %: string)))

(* Basic command *)
let command =
  Core.Std.Command.basic
    ~summary:"Parses function's callers and/or callees from callers's generated json files (direction=callers|callees|c2c)"
    ~readme:(fun () -> "More detailed information")
    spec
    (
      fun direction fct1_file fct1_id fct1_sign other () ->

      Printf.printf "extract_fcg:BEGIN: direction=%s fct1_id=\"%s\", fct_sign=\"%s\", fct1_file=%s\n" direction fct1_id fct1_sign fct1_file;

      let parser = new function_callers_json_parser fct1_id fct1_sign fct1_file other in

      let (fct1_filepath, fct1_filename) = Batteries.String.rsplit fct1_file "/" in
      let fct1_filekind = Common.file_get_kind fct1_filename in
      let entry_point_file : Callgraph_t.file =
        {
          name = fct1_filename;
          kind = fct1_filekind;
          includes = None;
          id = None;
          calls = None;
          called = None;
          virtcalls = None;
          (* records = None; *)
          declared = None;
          defined = None
        }
      in

      parser#complete_callgraph fct1_filepath (Some entry_point_file);

      (* let fct1_callgraph_json = Printf.sprintf "%s.fct.callgraph.gen.json" fct1_id in *)
      let fct1_callees_json = Printf.sprintf "%s.fcg.callees.gen.json" fct1_id in
      let fct1_callers_json = Printf.sprintf "%s.fcg.callers.gen.json" fct1_id in

      let fct1_callees_dot = Printf.sprintf "%s.fct.callees.gen.dot" fct1_id in
      let fct1_callers_dot = Printf.sprintf "%s.fct.callers.gen.dot" fct1_id in

      try
      (
	match direction with

	 | "callers" ->
	    (
	      let _ = parser#parse_declared_function_and_callers (fct1_sign) (fct1_file) in
	      parser#output_function_callers fct1_callers_dot;
              (* parser#output_file_callers_deps (); *)
              parser#output_fcg fct1_callers_json
	    )

	 | "callees" ->
	    (
	      let _ = parser#parse_defined_function_and_callees (fct1_sign) (fct1_file) in
	      parser#output_function_callees fct1_callees_dot;
              (* parser#output_file_calls_deps (); *)
              parser#output_fcg fct1_callees_json
	    )

	 | "c2c" ->
	    (match other with
	     | Some [fct2_file; fct2_id; fct2_sign; "files"]
	     | Some [fct2_file; fct2_id; fct2_sign ] ->
		(
                  let fct2_callers_json = Printf.sprintf "%s.fcg.callers.gen.json" fct2_id in
                  let fct2_callers_dot = Printf.sprintf "%s.fct.callers.gen.dot" fct2_id in

                  let fct2_c2c_json = Printf.sprintf "%s.fcg.c2c.gen.json" fct2_id in

		  Printf.printf "1) First retrieve all the callees of the caller function \"%s\ defined in file \"%s\"\n" fct1_sign fct1_file;
		  let _ = parser#parse_defined_function_and_callees (fct1_sign) (fct1_file) in

		  Printf.printf "2) Then retrieve all the callers of the callee function \"%s\ declared in file \"%s\"\n" fct2_sign fct2_file;
		  let _ = parser#parse_declared_function_and_callers (fct2_sign) (fct2_file) in

		  parser#output_function_callees fct1_callees_dot;
		  parser#output_function_callers fct2_callers_dot;

		  parser#output_fcg fct1_callees_json;
		  parser#output_fcg fct2_callers_json;

		  Printf.printf "3) Now we can retrieve all the paths between caller function \"%s\" and callee function \"%s\"\n" fct1_sign fct2_sign;
		  parser#output_function_c2c (Printf.sprintf "%s.%s.c2c.gen.dot" fct1_id fct2_id);
		  parser#output_fcg fct2_c2c_json
		)
	     | None
	     | _ ->
		(
		  Printf.printf "ERROR: \"c2c\" direction requires \"id\", \"sign\" and \"json\" file path of both caller fct1 and callee fct2 !\n";
		  Common.notify_error Common.Usage_Error
		)
	    )
	 | _ ->
	    (
	      Printf.printf "ERROR: unsupported direction \"%s\"" direction;
	      Common.notify_error Common.Internal_Error
	    )
      )
      with
      | Sys_error msg -> Printf.printf "extract_fcg.Sys_error: %s\n" msg
      | _ -> Printexc.record_backtrace true
      (* | Common.File_Not_Found -> Common.notify_error Common.File_Not_Found *)
      (* | _ -> Common.notify_error Common.Unexpected_Error *)
    )

(* Running Basic Commands *)
let () =
  Core.Std.Command.run ~version:"1.0" ~build_info:"RWO" command

(* Local Variables: *)
(* mode: tuareg *)
(* compile-command: "ocamlbuild -use-ocamlfind -package atdgen -package core -package yojson -tag thread extract_fcg.native" *)
(* compile-command: "ocamlbuild -use-ocamlfind -package atdgen -package core -package batteries -package ocamlgraph -package base64 -tag thread extract_fcg.native" *)
(* End: *)
