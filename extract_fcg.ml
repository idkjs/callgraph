(******************************************************************************)
(*   Copyright (C) 2014-2015 THALES Communication & Security                  *)
(*   All Rights Reserved                                                      *)
(*   European IST STANCE project (2011-2015)                                  *)
(*   author: Hugues Balp                                                      *)
(*                                                                            *)
(* This file generates dot graphs from json files generated by Callers        *)
(* and linked together thanks to some other OCAML backends                    *)
(******************************************************************************)

module Definitions = Map.Make(String);;
module Declarations = Map.Make(String);;
module Callers = Map.Make(String);;
module Callees = Map.Make(String);;
module Calls = Map.Make(String);;

type direction = Up | Down | UpAndDown;;

let string_of_dir (dir:direction) : string =

  (match dir with
   | Up -> "callers"
   | Down -> "callees"
   | UpAndDown -> "c2c"
  )

class function_callers_json_parser
	(callee_id:string)
	(callee_signature:string)
	(callee_json_filepath:string)
	(other:string list option)
	(* (root_directory:string)  *)
  = object(self)

  inherit Function_callgraph.function_callgraph

  val callee_id : string = callee_id

  val callee_sign : string = callee_signature

  val callee_file_path : string = callee_json_filepath

  val show_files : bool =

    (match other with
    | None -> false
    | Some args ->

      let show_files : string =
        try
          List.find
            (
              fun arg ->
                (match arg with
                | "files" -> true
                | _ -> false
                )
            )
            args
        with
          Not_found -> "none"
      in
      (match show_files with
      | "files" -> true
      | "none"
      | _ -> false
      )
    )

  (* Function callers graph *)
  val mutable gfct_callers : Graph_func.G.t = Graph_func.G.empty

  (* Function callees graph *)
  val mutable gfct_callees : Graph_func.G.t = Graph_func.G.empty

  (* Function caller to callee  graph *)
  val mutable gfct_c2c : Graph_func.G.t = Graph_func.G.empty

  val mutable callees_table = Callees.empty
  val mutable callers_table = Callees.empty

  val mutable callees_calls_table = Calls.empty
  val mutable callers_calls_table = Calls.empty

  (* Tables to ensure function's decalarations and definitions are visited only once *)
  val mutable parsed_defined_functions = Definitions.empty
  val mutable parsed_declared_functions = Declarations.empty

  (* Add a dot vertex in the dot graph for the input function *)
  method dot_graph_add_function (dir:direction) (fct_sign:string) (json_file:string) : Graph_func.function_decl =

    let fct : Graph_func.function_decl = self#dump_fct fct_sign json_file in
    (match dir with
     | Up ->        ( gfct_callers <- Graph_func.G.add_vertex gfct_callers fct )
     | Down ->      ( gfct_callees <- Graph_func.G.add_vertex gfct_callees fct )
     | UpAndDown -> ( gfct_c2c     <- Graph_func.G.add_vertex gfct_c2c fct )
    );
    fct

  (* Add a file in the callgraph if not present *)
  method callgraph_add_file (filepath:string) : Callgraph_t.file =

    Printf.printf "extract_fcg.callgraph_add_file:BEGIN: %s\n" filepath;

    (* let rdir = self#get_fcg_rootdir in *)
    (* try *)
    (*   ( *)
    (*     let file = self#get_file rdir filepath in *)
    let (filepath, filename) = Batteries.String.rsplit filepath "/" in
    (* (match file with *)
    (*  | None -> *)
    (*     ( *)
    let file : Callgraph_t.file =
      {
        name = filename;
        uses = None;
        declared = None;
        defined = None;
      }
    in
    let rdir = self#get_fcg_rootdir in
    let file = self#complete_fcg_file rdir filepath file in
    (*         ) *)
    (*      | Some _ -> () *)
    (*     ) *)
    (*   ) *)
    (* with *)
    (*   Common.Usage_Error -> *)
    (*   ( *)
    (*     Printf.printf "DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD\n"; *)
    (*     Printf.printf "extract_fcg.callgraph_add_file:DEBUG: Usage_Error: rdir=%s, filepath=%s\n" rdir.name filepath; *)
    (*     Printf.printf "DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD\n"; *)
    (*     () *)
    (*   ) *)

    Printf.printf "extract_fcg.callgraph_add_file:END: %s\n" filepath;
    file

  (* Add a node in the callgraph for the input function *)
  method callgraph_add_declared_function (fct_sign:string) (fct_filepath:string) : Callgraph_t.fonction =

    Printf.printf "extract_fcg.callgraph_add_declared_function:BEGIN: fct_sign=%s filepath=%s\n" fct_sign fct_filepath;

    let rdir = self#get_fcg_rootdir in
    let fct_decl : Callgraph_t.fonction =
      {
        sign = fct_sign;
        extcallers = None;
        extcallees = None;
        locallers = None;
        locallees = None
      }
    in
    (try
        (
          let file = self#get_file rdir fct_filepath in
          let file =
            (match file with
             | None -> self#callgraph_add_file fct_filepath
             | Some file -> file
            )
          in
          (
            let does_already_exist = self#get_fct_decl file fct_sign in
            (match does_already_exist with
             | None -> self#add_fct_decls file [fct_decl]
             | Some _ -> Printf.printf "Do not add already existing declared function \"%s\"\n" fct_sign
            )
          )
        )
      with
        Common.Usage_Error ->
        (
          Printf.printf "DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD\n";
          Printf.printf "extract_fcg.callgraph_add_declared_function:DEBUG: Usage_Error: rdir=%s, fct_filepath=%s\n" rdir.name fct_filepath;
          Printf.printf "DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD\n"
        )
    );
    Printf.printf "extract_fcg.callgraph_add_declared_function:END fct_sign=%s filepath=%s\n" fct_sign fct_filepath;
    fct_decl

  (* Add a node in the callgraph for the input function *)
  method callgraph_add_defined_function (fct_sign:string) (fct_filepath:string) : Callgraph_t.fonction =

    Printf.printf "extract_fcg.callgraph_add_defined_function:BEGIN: fct_sign=%s filepath=%s\n" fct_sign fct_filepath;

    let rdir = self#get_fcg_rootdir in
    let fct_def : Callgraph_t.fonction =
      {
        sign = fct_sign;
        extcallers = None;
        extcallees = None;
        locallers = None;
        locallees = None
      }
    in
    (try
        (
          let file = self#get_file rdir fct_filepath in
          let file =
            (match file with
             | None -> self#callgraph_add_file fct_filepath
             | Some file -> file
            )
          in
          (
            let does_already_exist = self#get_fct_def file fct_sign in
            (match does_already_exist with
             | None -> self#add_fct_defs file [fct_def]
             | Some _ -> Printf.printf "Do not add already existing defined function \"%s\"\n" fct_sign
            )
          )
        )
      with
        Common.Usage_Error ->
        (
          Printf.printf "DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD\n";
          Printf.printf "extract_fcg.callgraph_add_defined_function:DEBUG: Usage_Error: rdir=%s, fct_filepath=%s\n" rdir.name fct_filepath;
          Printf.printf "DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD\n";
          ()
        )
    );
    Printf.printf "extract_fcg.callgraph_add_defined_function:END: fct_sign=%s filepath=%s\n" fct_sign fct_filepath;
    fct_def

  method dump_fct (fct_sign:string) (json_file:string) : Graph_func.function_decl =

    (* Replace all / by _ in the file path *)
    let fpath : string = Str.global_replace (Str.regexp "\\/") "_" json_file in

    (* Replace all '.' by '_' in the file path *)
    let fpath : string = Str.global_replace (Str.regexp "\\.") "_" fpath in

    (* Replace all '-' by '_' in the file path *)
    let fpath : string = Str.global_replace (Str.regexp "\\-") "_" fpath in

    (* Replace all '+' by 'p' in the file path *)
    let fpath : string = Str.global_replace (Str.regexp "\\+") "p" fpath in

    let filename : string = Filename.basename json_file in

    let file : Graph.Graphviz.DotAttributes.subgraph option =
      if show_files then
	Some
    	  {
    	    sg_name = fpath;
    	    sg_attributes = [ `Label filename ];
    	    (* sg_parent = Some class_memberdef_factory.file.sg_name; *)
    	    sg_parent = None;
    	  }
      else
	None
    in
    let v : Graph_func.function_decl =
      {
	id = fct_sign;
	name = fct_sign;
	file_path = json_file;
	line = "unknownFunctionLine";
	bodyfile = json_file;
	bodystart = "unknownBodyStart";
	bodyend = "unknownBodyEnd";
	return_type = "unknownFunctionReturnType";
	argsstring = "unknownFunctionArgs";
	params = [];
	callers = [];
	callees = [];
	file = file
      }
    in
    v

  method parse_declared_function (fct_def:string) : unit =

    parsed_declared_functions <- Definitions.add fct_def true parsed_declared_functions

  method parsed_declared_function (fct_def:string) : bool =

    try
      Definitions.find fct_def parsed_declared_functions
    with
      Not_found -> false

  method parse_defined_function (fct_def:string) : unit =

    parsed_defined_functions <- Definitions.add fct_def true parsed_defined_functions

  method parsed_defined_function (fct_def:string) : bool =

    try
      Definitions.find fct_def parsed_defined_functions
    with
      Not_found -> false

  method callees_register_function_call (call:string) : unit =

    Printf.printf "extract_fcg.callees_register_function_call:INFO: %s\n" call;

    callees_calls_table <- Calls.add call true callees_calls_table

  method callees_registered_as_function_call (call:string) : bool =

    let registered =
      try
        Calls.find call callees_calls_table
      with
        Not_found -> false
    in
    Printf.printf "extract_fcg.callees_registered_as_function_call:INFO: %s: %b\n" call registered;
    registered

  method callers_register_function_call (call:string) : unit =

    callers_calls_table <- Calls.add call true callers_calls_table

  method callers_registered_as_function_call (call:string) : bool =

    try
      Calls.find call callers_calls_table
    with
      Not_found -> false

  method register_function_callee (fct_sign:string) : unit =

    callees_table <- Callees.add fct_sign true callees_table

  method registered_as_function_callee (fct_sign:string) : bool =

    try
      Callees.find fct_sign callees_table
    with
      Not_found -> false

  method register_function_caller (fct_sign:string) : unit =

    callers_table <- Callers.add fct_sign true callers_table

  method registered_as_function_caller (fct_sign:string) : bool =

    try
      Callers.find fct_sign callers_table
    with
      Not_found -> false

  method parse_called_declared_function (fct_sign:string) (json_file:string)
         : (Callgraph_t.fonction * Graph_func.function_decl) option =

    Printf.printf "extract_fcg.parse_called_declared_function:BEGIN fct_sign=%s json_file=%s\n";

    let vcaller = self#dot_graph_add_function Down fct_sign json_file in
    (* Parse declared function *)
    let fct = self#parse_declared_fct_in_file fct_sign json_file in
    let called_decl =
      (match fct with
       | None ->
          (
            Printf.printf "extract_fcg.parse_called_declared_function:WARNING: the function \"%s\" is not declared in file \"%s\" !\n" fct_sign json_file;
            None
          )
       | Some fct ->
          (
            let fct_decl = self#callgraph_add_declared_function fct_sign json_file in
            Some (fct_decl, vcaller)
          )
      )
    in
    (match called_decl with
    | None -> Printf.printf "extract_fcg.parse_called_declared_function:RETURN: No called declared function returned\n"
    | Some (f, _) -> Printf.printf "extract_fcg.parse_called_declared_function:RETURN: returned declared function \"%s\"\n" f.sign
    );
    Printf.printf "extract_fcg.parse_called_declared_function:END fct_sign=%s json_file=%s\n";
    called_decl

  method parse_called_defined_function_and_callees (fct_sign:string) (json_file:string)
         : (Callgraph_t.fonction * Graph_func.function_decl) option =

    Printf.printf "extract_fcg.parse_called_defined_function_and_callees:BEGIN fct_sign=%s json_file=%s\n";

    let vcaller = self#dot_graph_add_function Down fct_sign json_file in

    (* Parse current function *)
    let fct = self#parse_defined_fct_in_file fct_sign json_file in

    let called_fct : (Callgraph_t.fonction * Graph_func.function_decl) option =

      (match fct with
       | None ->
          (
            Printf.printf "WARNING: the function \"%s\" is not defined in file \"%s\" !\n" fct_sign json_file;
            None
          )
       | Some fct ->
          (
            let fct_def = self#callgraph_add_defined_function fct_sign json_file in

            (* Parse local callees *)
            (match fct.locallees with
             | None -> ()
             | Some locallees ->
	        Printf.printf "Parse local callees...\n";
	        List.iter
	          ( fun (f:string) ->
	            Printf.printf "visit locallee: %s...\n" f;
	            let vcallee = self#parse_defined_function_and_callees (f) (json_file) (fct_sign) (Some vcaller) in
	            (match vcallee with
	             | None -> () (* cycle probably detected *)
	             | Some (fcallee, vcallee) ->
                        (
		          gfct_callees <- Graph_func.G.add_edge_e gfct_callees (Graph_func.G.E.create vcaller "internal" vcallee);
                          Printf.printf "HBDBG_1\n";
                          self#add_fct_locallee fct_def fcallee.sign
                        )
	            )
	          )
	          locallees
            );

            (* Parse remote callees *)
            (match fct.extcallees with
             | None -> ()
             | Some extcallees ->
	        Printf.printf "Parse remote callees...\n";
	        List.iter
	          ( fun (f:Callers_t.extfct) ->

	            (match f.decl with
	             | "unknownExtFctDecl" ->
		        (
		          Printf.printf "wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww\n";
		          Printf.printf "WARNING: Unable to visit unknown extcallee declaration: %s\n" f.sign;
		          Printf.printf "caller sign is: %s\n" fct.sign;
		          Printf.printf "callee decl is: %s\n" f.decl;
		          Printf.printf "wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww\n";
		          let loc : string list = Str.split_delim (Str.regexp ":") f.decl in
		          let file =
		            (match loc with
		             | [ file; _ ] ->  file
		             | _ -> raise Common.Internal_Error
		            )
		          in
		          let vcallee : Graph_func.function_decl = self#dump_fct f.sign file in
		          gfct_callees <- Graph_func.G.add_edge_e gfct_callees (Graph_func.G.E.create vcaller "external" vcallee)
		        )
	             | "unlinkedExtCalleeDecl" ->
		        (
		          Printf.printf "wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww\n";
		          Printf.printf "WARNING: Unable to visit unlinked extcallee declaration: %s\n" f.sign;
		          Printf.printf "caller sign is: %s\n" fct.sign;
		          Printf.printf "callee decl is: %s\n" f.decl;
		          Printf.printf "wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww\n";
		          let loc : string list = Str.split_delim (Str.regexp ":") f.decl in
		          let file =
		            (match loc with
		             | [ file; _ ] ->  file
		             | _ -> raise Common.Internal_Error
		            )
		          in
		          let vcallee : Graph_func.function_decl = self#dump_fct f.sign file in
		          gfct_callees <- Graph_func.G.add_edge_e gfct_callees (Graph_func.G.E.create vcaller "external" vcallee)
		        )
	             | "builtinFunctionDecl" ->
		        (
		          let loc : string list = Str.split_delim (Str.regexp ":") f.decl in
		          let file =
		            (match loc with
		             | [ file; _ ] ->  file
		             | _ -> raise Common.Internal_Error
		            )
		          in
		          let vcallee : Graph_func.function_decl = self#dump_fct f.sign file in
		          gfct_callees <- Graph_func.G.add_edge_e gfct_callees (Graph_func.G.E.create vcaller "external" vcallee)
 		        )
	             | _ ->
		        (
		          let loc : string list = Str.split_delim (Str.regexp ":") f.decl in
		          let decl_file =
		            (match loc with
		             | [ file; line ] ->
			        (
			          if (String.compare line "-1" == 0) then
			            Printf.printf "WARNING: the function \"%s\" is probably a builtin function\n" fct_sign;

			          if (String.compare f.def "unlinkedExtCallee" == 0) then
			            Printf.printf "WARNING: the function \"%s\" is most probably an unlinked builtin function\n" fct_sign;

			          file
			        )
		             | _ -> raise Common.Internal_Error
		            )
		          in
		          let vcallee = self#parse_declared_function_and_callees (f.sign) (decl_file) (fct_sign) (Some vcaller) in
		          (* let vcallee = self#parse_declared_function_and_callees (f.sign) (decl_file) (gcaller_sign) (Some vcaller) in *)
		          (* let vcallee = self#parse_declared_function_and_callees (f.sign) (decl_file) (gcaller_sign) (gcaller_v) in *)
		          (match vcallee with
		           (* | None -> raise Common.Internal_Error *)
		           | None -> () (* cycle probably detected *)
		           | Some vcallee -> ()
		          (* ( *)
		          (*   if self#parsed_defined_function declared_fct_index then *)
		          (*     ( *)
		          (*       Printf.printf "HBDBG: parse_declared_function_and_callees:INFO:ALREADY_PARSED_DEF: callee_sign=\"%s\" json_file=\"%s\" caller_sign=\"%s\"\n" fct_sign file gcaller_sign *)
		          (*     ) *)
		          (*   else *)
		          (*     ( *)
		          (*       Printf.printf "HBDBG: parse_declared_function_and_callees:INFO:PRINT_DEF: callee_sign=\"%s\" json_file=\"%s\" caller_sign=\"%s\"\n" fct_sign file gcaller_sign; *)
		          (* *)
		          (*       (match gcaller_v with *)
		          (*        | None ->  *)
		          (* 	  ( *)
		          (* 	    gfct_callees <- Graph_func.G.add_edge_e gfct_callees (Graph_func.G.E.create vcaller "extern" vcallee) *)
		          (* 	  ) *)
		          (*        | Some gcaller ->  *)
		          (* 	  ( *)
		          (* 	    (\* raise Common.Internal_Error; *\) *)
		          (* 	    gfct_callees <- Graph_func.G.add_edge_e gfct_callees (Graph_func.G.E.create gcaller "cycle" vcallee) *)
		          (* 	  ) *)
		          (*       ) *)
		          (*     ) *)
		          (* ) *)
		          )
		        )
	            );

	            (match f.def with
	             | "unknownExtFctDef" ->
		        (
		          Printf.printf "wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww\n";
		          Printf.printf "WARNING: Unable to visit unknown extcallee: %s\n" f.sign;
		          Printf.printf "caller sign is: %s\n" fct.sign;
		          Printf.printf "callee decl is: %s\n" f.decl;
		          Printf.printf "wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww\n";
		          let loc : string list = Str.split_delim (Str.regexp ":") f.decl in
		          let file =
		            (match loc with
		             | [ file; _ ] ->  file
		             | _ -> raise Common.Internal_Error
		            )
		          in
		          let vcallee : Graph_func.function_decl = self#dump_fct f.sign file in
		          gfct_callees <- Graph_func.G.add_edge_e gfct_callees (Graph_func.G.E.create vcaller "external" vcallee)
		        )
	             | "unlinkedExtCallee" ->
		        (
		          Printf.printf "wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww\n";
		          Printf.printf "WARNING: Unable to visit unlinked extcallee: %s\n" f.sign;
		          Printf.printf "caller sign is: %s\n" fct.sign;
		          Printf.printf "callee decl is: %s\n" f.decl;
		          Printf.printf "wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww\n";
		          let loc : string list = Str.split_delim (Str.regexp ":") f.decl in
		          let file =
		            (match loc with
		             | [ file; _ ] ->  file
		             | _ -> raise Common.Internal_Error
		            )
		          in
		          let vcallee : Graph_func.function_decl = self#dump_fct f.sign file in
		          gfct_callees <- Graph_func.G.add_edge_e gfct_callees (Graph_func.G.E.create vcaller "external" vcallee)
		        )
	             | "builtinFunctionDef" ->
		        (
		          let loc : string list = Str.split_delim (Str.regexp ":") f.decl in
		          let file =
		            (match loc with
		             | [ file; _ ] ->  file
		             | _ -> raise Common.Internal_Error
		            )
		          in
		          let vcallee : Graph_func.function_decl = self#dump_fct f.sign file in
		          gfct_callees <- Graph_func.G.add_edge_e gfct_callees (Graph_func.G.E.create vcaller "external" vcallee)
 		        )
	             | _ ->
		        (
		          let loc : string list = Str.split_delim (Str.regexp ":") f.def in
		          let file =
		            (match loc with
		             | [ file; _ ] ->  file
		             | _ -> raise Common.Internal_Error
		            )
		          in
		          let vcallee = self#parse_defined_function_and_callees (f.sign) (file) (fct_sign) (Some vcaller) in
		          (match vcallee with
		           (* | None -> raise Common.Internal_Error *)
		           | None ->
                              (
                                Printf.printf "extract_fcg.function_callers_json_parser:WARNING: no vcallee returned\n";
                                ()
                              )
		           | Some (fcallee, vcallee) ->
                              (
                                gfct_callees <- Graph_func.G.add_edge_e gfct_callees (Graph_func.G.E.create vcaller "external" vcallee);
                                Printf.printf "HBDBG_2\n";
                                self#add_fct_extcallee fct_def fcallee.sign
                              )
		          )
		        )
	            )
	          )
	          extcallees
            );

            Some (fct_def, vcaller)
          )
      )
    in
    (match called_fct with
    | None -> Printf.printf "extract_fcg.parse_called_defined_function_and_callees:RETURN: No defined function returned\n"
    | Some (f, _) -> Printf.printf "extract_fcg.parse_called_defined_function_and_callees:RETURN: returned defined function \"%s\"\n" f.sign
    );
    Printf.printf "extract_fcg.parse_called_defined_function_and_callees:END fct_sign=%s json_file=%s\n";
    called_fct

  method parse_defined_function_and_callees (fct_sign:string) (json_file:string)
 					     (gcaller_sign:string) (gcaller_v:Graph_func.function_decl option)
	 : (Callgraph_t.fonction * Graph_func.function_decl) option =

    let defined_fct_index = String.concat ":" [ fct_sign; json_file; gcaller_sign ] in

    let output : (Callgraph_t.fonction * Graph_func.function_decl) option =

      (* Commented out the test below because we generate a call tree where the same called functions can be duplicated at several places *)
      (* An alternative would be to use a binary tree and references to each individual functions *)
      (* if self#parsed_defined_function defined_fct_index then *)
      (*   ( *)
      (*     Printf.printf "extract_fcg.parse_defined_function_and_callees:DEBUG:ALREADY_PARSED: callee_sign=\"%s\" json_file=\"%s\" caller_sign=\"%s\"\n" fct_sign json_file gcaller_sign; *)
      (*     None *)
      (*   ) *)
      (* else *)
        (
	  self#parse_defined_function defined_fct_index;

	  Printf.printf "extract_fcg.parse_defined_function_and_callees:BEGIN: callee_sign=\"%s\" json_file=\"%s\" caller_sign=\"%s\"\n" fct_sign json_file gcaller_sign;

	  let call : string = String.concat "" [ gcaller_sign; " -> "; fct_sign ]
	  in

	  (* if (self#registered_as_function_callee fct_sign) *)
	  (*    && (self#callees_registered_as_function_call call) then *)
	  (*   ( *)
	  (*     Printf.printf "extract_fcg.parse_defined_function_and_callees:WARNING: callee cycle detected including defined function \"%s\"\n" fct_sign; *)
	  (*     (\* (match gcaller_v with *\) *)
	  (*     (\* | None -> raise Common.Internal_Error *\) *)
	  (*     (\* | Some gcaller ->  *\) *)
	  (*     (\* 	 gfct_callees <- Graph_func.G.add_edge_e gfct_callees (Graph_func.G.E.create gcaller "cycle" vcaller) *\) *)
	  (*     (\* ); *\) *)
	  (*     None *)
	  (*   ) *)
	  (* else *)
	    (
              let callee_fct : (Callgraph_t.fonction * Graph_func.function_decl) option =

	        (* if not(self#registered_as_function_callee fct_sign) then *)
		  (
		    self#register_function_callee fct_sign;

                    let fct_def = self#parse_called_defined_function_and_callees fct_sign json_file in
                    (match fct_def with
                     | Some _ ->
                        (
                          fct_def
                        )
                     | None ->
                        (
                          let fct_decl = self#parse_called_declared_function fct_sign json_file in
                          fct_decl
                        )
                    )
		  )
                (* else *)
                (*   ( *)
                (*     (\* Commented out the test below because we generate a call tree where the same called functions can be duplicated at several places *\) *)
                (*     (\* An alternative would be to use a binary tree and references to each individual functions *\) *)
	        (*     Printf.printf "extract_fcg.parse_defined_function_and_callees:DEBUG:ALREADY_PARSED_FCT_CALLEE: callee_sign=\"%s\" json_file=\"%s\" caller_sign=\"%s\"\n" fct_sign json_file gcaller_sign; *)
                (*     None *)
                (*   ) *)
              in
	      if not(self#callees_registered_as_function_call call) then
		self#callees_register_function_call call;
              callee_fct
	    )
        )
    in
    (match output with
    | None -> Printf.printf "extract_fcg.parse_defined_function_and_callees:RETURN: No called function returned\n"
    | Some (f, _) -> Printf.printf "extract_fcg.parse_defined_function_and_callees:RETURN: returned function \"%s\" called by \"%s\"\n" f.sign gcaller_sign
    );
    Printf.printf "extract_fcg.parse_defined_function_and_callees:END: callee_sign=\"%s\" json_file=\"%s\" caller_sign=\"%s\"\n" fct_sign json_file gcaller_sign;
    output

  method parse_declared_function_and_callees (fct_sign:string) (json_file:string)
					     (gcaller_sign:string) (gcaller_v:Graph_func.function_decl option)
	 : (Callgraph_t.fonction * Graph_func.function_decl) option =

    let declared_fct_index = String.concat ":" [ fct_sign; json_file; gcaller_sign ] in

    if self#parsed_declared_function declared_fct_index then
      (
	(* Printf.printf "DEBUG: parse_declared_function_and_callees:INFO:ALREADY_PARSED_DECL: callee_sign=\"%s\" json_file=\"%s\" caller_sign=\"%s\"\n" fct_sign json_file gcaller_sign; *)
	None
      )
    else
      (
	self#parse_declared_function declared_fct_index;

	Printf.printf "extract_fcg.parse_declared_function_and_callees:BEGIN: callee_sign=\"%s\" json_file=\"%s\" caller_sign=\"%s\"\n" fct_sign json_file gcaller_sign;

	(* Parse current function *)
	let fct : Callers_t.fct_decl option = self#parse_declared_fct_in_file fct_sign json_file in

	(match fct with
	 | None ->
	    Printf.printf "extract_fcg.parse_declared_function_and_callees:WARNING: no function found in file \"%s\" with signature=\"%s\" !\n"
			  json_file fct_sign;
	    None

	 | Some fct ->
	    (
              let vcaller = self#dot_graph_add_function Down fct.sign json_file in

              let fct_decl = self#callgraph_add_declared_function fct.sign json_file in

	      (* let vcaller : Graph_func.function_decl = self#dump_fct fct.sign json_file in *)
	      (* gfct_callees <- Graph_func.G.add_vertex gfct_callees vcaller; *)

	      let call : string = String.concat "" [ gcaller_sign; " -> "; fct_sign ]
	      in

	      (* if (self#registered_as_function_callee fct_sign) *)
	      (*    && (self#callees_registered_as_function_call call) then *)
	      (* (\* if (self#callees_registered_as_function_call call) then *\) *)
	      (* (\* if (self#registered_as_function_callee fct_sign) then *\) *)
	      (*   ( *)
	      (*     Printf.printf "WARNING: callee cycle detected including declared function \"%s\"\n" fct_sign; *)
	      (*     (match gcaller_v with *)
	      (*     | None -> raise Common.Internal_Error *)
	      (*     | Some gcaller -> *)
	      (*     	 gfct_callees <- Graph_func.G.add_edge_e gfct_callees (Graph_func.G.E.create gcaller "cycle" vcaller) *)
	      (*     ); *)
	      (*     None *)
	      (*   ) *)
	      (* else *)
	      (
		(* if not(self#callees_registered_as_function_call call) then *)
	      	(*   self#callees_register_function_call call; *)

		(* if not(self#registered_as_function_callee fct_sign) then *)
		(* 	self#register_function_callee fct_sign; *)

		(match fct.virtuality with
                 | None
		 | Some "no" -> Printf.printf "The function \"%s\" is not virtual\n" fct_sign
		 | Some "declared" -> Printf.printf "The function \"%s\" is declared as virtual\n" fct_sign
		 | Some "defined" -> Printf.printf "The function \"%s\" is defined as virtual\n" fct_sign
		 | Some "pure" -> Printf.printf "The function \"%s\" is virtual pure\n" fct_sign
		 | _ -> raise Common.Unsupported_Virtuality_Keyword
		);

		(* Parse definitions *)
		(match fct.definitions with
		 | None -> ()
		 | Some definitions ->
		    Printf.printf "Parse definitions...\n";
		    List.iter
		      ( fun (f:string) ->
			Printf.printf "visit definition: %s...\n" f;
			let loc : string list = Str.split_delim (Str.regexp ":") f in
			let file =
			  (match loc with
			   | [ file; _ ] ->  file
			   | _ -> raise Common.Internal_Error
			  )
			in
			(* let vcallee = self#parse_defined_function_and_callees (fct_sign) (file) (gcaller_sign) (Some vcaller) in *)
			let vcallee = self#parse_defined_function_and_callees (fct_sign) (file) (gcaller_sign) (gcaller_v) in
			(match vcallee with
			 | None -> () (* cycle probably detected *)
			 | Some (fcallee, vcallee) ->
			    (* gfct_callees <- Graph_func.G.add_edge_e gfct_callees (Graph_func.G.E.create vcaller "internal" vcallee) *)
			    (match gcaller_v with
			     | None ->
				(
				  gfct_callees <- Graph_func.G.add_edge_e gfct_callees (Graph_func.G.E.create vcaller "cycle" vcallee);
                                  Printf.printf "HBDBG_3\n";
                                  self#add_fct_locallee fct_decl fcallee.sign
				)
			     | Some gcaller ->
				(
				  if self#parsed_defined_function declared_fct_index then
				    (
				      Printf.printf "HBDBG: parse_declared_function_and_callees:INFO:ALREADY_PARSED_DEF: callee_sign=\"%s\" json_file=\"%s\" caller_sign=\"%s\"\n" fct_sign file gcaller_sign
				    )
				  else
				    (
				      Printf.printf "HBDBG: parse_declared_function_and_callees:INFO:PRINT_DEF: callee_sign=\"%s\" json_file=\"%s\" caller_sign=\"%s\"\n" fct_sign file gcaller_sign;
				      gfct_callees <- Graph_func.G.add_edge_e gfct_callees (Graph_func.G.E.create gcaller "external" vcallee)
				    )
				)
			    )
			)
		      )
		      definitions
		);

		(* Parse remote callees *)
		(match fct.redeclarations with
		 | None -> ()
		 | Some redeclarations ->
		    Printf.printf "Parse redeclarations...\n";
		    List.iter
		      ( fun (f:Callers_t.extfct) ->

			(match f.decl with
			 | "unknownExtFctDecl" ->
			    (
			      Printf.printf "wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww\n";
			      Printf.printf "WARNING: Unable to visit unknown redeclared function: %s\n" f.sign;
			      Printf.printf "caller sign is: %s\n" fct.sign;
			      Printf.printf "callee decl is: %s\n" f.decl;
			      Printf.printf "wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww\n";
			      let loc : string list = Str.split_delim (Str.regexp ":") f.decl in
			      let file =
				(match loc with
				 | [ file; _ ] ->  file
				 | _ -> raise Common.Internal_Error
				)
			      in
			      let vcallee : Graph_func.function_decl = self#dump_fct f.sign file in
			      gfct_callees <- Graph_func.G.add_edge_e gfct_callees (Graph_func.G.E.create vcaller "external" vcallee)
			    )
			 | "unlinkedRedeclaredFunction" ->
			    (
			      Printf.printf "wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww\n";
			      Printf.printf "WARNING: Unable to visit unlinked redeclared function: %s\n" f.sign;
			      Printf.printf "caller sign is: %s\n" fct.sign;
			      Printf.printf "callee decl is: %s\n" f.decl;
			      Printf.printf "wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww\n";
			      let loc : string list = Str.split_delim (Str.regexp ":") f.decl in
			      let file =
				(match loc with
				 | [ file; _ ] ->  file
				 | _ -> raise Common.Internal_Error
				)
			      in
			      let vcallee : Graph_func.function_decl = self#dump_fct f.sign file in
			      gfct_callees <- Graph_func.G.add_edge_e gfct_callees (Graph_func.G.E.create vcaller "external" vcallee)
			    )
			 | "builtinFunctionDecl" ->
			    (
			      let loc : string list = Str.split_delim (Str.regexp ":") f.decl in
			      let file =
				(match loc with
				 | [ file; _ ] ->  file
				 | _ -> raise Common.Internal_Error
				)
			      in
			      let vcallee : Graph_func.function_decl = self#dump_fct f.sign file in
			      gfct_callees <- Graph_func.G.add_edge_e gfct_callees (Graph_func.G.E.create vcaller "external" vcallee)
 			    )
			 | _ ->
			    (
			      let loc : string list = Str.split_delim (Str.regexp ":") f.decl in
			      let file =
				(match loc with
				 | [ file; _ ] ->  file
				 | _ -> raise Common.Internal_Error
				)
			      in
			      (* let vcallee = self#parse_declared_function_and_callees (f.sign) (file) (fct_sign) (Some vcaller) in *)
			      let vcallee = self#parse_declared_function_and_callees (f.sign) (file) (gcaller_sign) (gcaller_v) in
			      (match vcallee with
			       (* | None -> raise Common.Internal_Error *)
			       | None -> () (* cycle probably detected *)
			       | Some vcallee -> ()

				  (* gfct_callees <- Graph_func.G.add_edge_e gfct_callees (Graph_func.G.E.create vcaller "external" vcallee) *)
				  (*  *)
				  (* (match gcaller_v with *)
				  (*  | None ->  *)
				  (*     ( *)
				  (* 	gfct_callees <- Graph_func.G.add_edge_e gfct_callees (Graph_func.G.E.create vcaller "cycle" vcallee) *)
				  (*     ) *)
				  (*  | Some gcaller ->  *)
				  (*     ( *)
				  (* 	(\* raise Common.Internal_Error; *\) *)
				  (* 	gfct_callees <- Graph_func.G.add_edge_e gfct_callees (Graph_func.G.E.create gcaller "external" vcallee) *)
				  (*     ) *)
				  (* ) *)
			      )
			    )
			)
		      )
		      redeclarations
		);
		Some (fct_decl, vcaller)
	      )
	    )
	)
      )

  method parse_declared_function_and_callers (fct_sign:string) (json_file:string)
					    (gcallee_sign:string) (gcallee_v:Graph_func.function_decl option)
	 : (Callgraph_t.fonction * Graph_func.function_decl) option =

    Printf.printf "DEBUG: parse_declared_function_and_callers: caller_sign=\"%s\" json_file=\"%s\" callee_sign=\"%s\"\n" fct_sign json_file gcallee_sign;
    (* Parse current function *)
    let fct : Callers_t.fct_decl option = self#parse_declared_fct_in_file fct_sign json_file in

    (match fct with

     | None ->

	Printf.printf "extract_fcg.parse_declared_function_and_callers:WARNING: no function declared in file \"%s\" with signature=\"%s\" !\n"
		      json_file fct_sign;
	None

     | Some fct ->
	(
	  (* let vcallee : Graph_func.function_decl = self#dump_fct fct.sign json_file in *)
	  (* gfct_callers <- Graph_func.G.add_vertex gfct_callers vcallee; *)

          let vcallee = self#dot_graph_add_function Up fct.sign json_file in

          let fct_def = self#callgraph_add_defined_function fct.sign json_file in

	  let call : string = String.concat "" [ fct_sign; " -> "; gcallee_sign ]
	  in

	  if (self#registered_as_function_caller fct_sign)
	     && (self#callers_registered_as_function_call call) then
	    (
	      Printf.printf "WARNING: caller cycle detected including function \"%s\"\n" fct_sign;
	      (match gcallee_v with
	       | None -> raise Common.Internal_Error
	       | Some gcallee ->
		  gfct_callers <- Graph_func.G.add_edge_e gfct_callers (Graph_func.G.E.create vcallee "cycle" gcallee)
	      );
	      None
	    )
	  else
	    (
	      if not(self#callers_registered_as_function_call call) then
		self#callers_register_function_call call;

	      if not(self#registered_as_function_caller fct_sign) then
		(
		  self#register_function_caller fct_sign;

		  if self#registered_as_function_callee fct_sign then
		    (
		      gfct_c2c <- Graph_func.G.add_vertex gfct_c2c vcallee;
		    );

		  (* Parse local callers *)
		  (match fct.locallers with
		   | None -> ()
		   | Some locallers ->
		      Printf.printf "extract_fcg.parse_declared_function_and_callers:INFO: Parse local callers...\n";
		      List.iter
			( fun (f:string) ->
			  let vcaller = self#parse_declared_function_and_callers f json_file fct_sign (Some vcallee) in
			  (match vcaller with

			  | None -> raise Common.Internal_Error (* cycle probably detected *)

			  | Some (fcaller, vcaller) ->
			      (
				gfct_callers <- Graph_func.G.add_edge_e gfct_callers (Graph_func.G.E.create vcaller "internal" vcallee);
                                Printf.printf "HBDBG_4\n";
                                self#add_fct_localler fct_def fcaller.sign;

				if (self#registered_as_function_callee fct_sign) &&
				     (self#registered_as_function_callee f)
				then
				  (
				    gfct_c2c <- Graph_func.G.add_edge_e gfct_c2c (Graph_func.G.E.create vcaller "internal" vcallee);
				  )
			      )
			  )
			)
			locallers
		  );

		  (* Parse remote callers *)
		  (match fct.extcallers with
		  | None -> ()
		  | Some extcallers ->
		      Printf.printf "Parse remote callers...\n";
		      List.iter
			( fun (f:Callers_t.extfct) ->

			  (match f.def with
                          | "unknownExtFctDef" ->
                             (
                               Printf.printf "wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww\n";
                               Printf.printf "WARNING: Unable to visit unknown extcaller: %s\n" f.sign;
                               Printf.printf "caller sign is: %s\n" fct.sign;
                               Printf.printf "caller decl is: %s\n" f.decl;
                               Printf.printf "wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww\n";
                               let loc : string list = Str.split_delim (Str.regexp ":") f.decl in
                               let file =
                                 (match loc with
                                  | [ file; _ ] ->  file
                                  | _ -> raise Common.Internal_Error
                                 )
                               in
                               let vcaller : Graph_func.function_decl = self#dump_fct f.sign file in
                               gfct_callers <- Graph_func.G.add_edge_e gfct_callers (Graph_func.G.E.create vcaller "external" vcallee)
                             )
			  | "unlinkedExtCaller" ->
			      (
				Printf.printf "wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww\n";
				Printf.printf "Unable to visit unlinked extcaller: %s\n" f.sign;
				Printf.printf "Current caller is: %s\n" fct.sign;
				Printf.printf "wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww\n";
			      )
			  | _ ->
			    (
			      let file =
				let loc : string list = Str.split_delim (Str.regexp ":") f.def in
				(match loc with
				| [ file; _ ] ->  file
				| _ ->
				  (
				    Printf.printf "DEBUG: f.def: %s" f.def;
				    raise Common.Internal_Error
				  )
				)
			      in
			      let vcaller = self#parse_declared_function_and_callers f.sign file fct_sign (Some vcallee) in
			      (match vcaller with
			      | None -> raise Common.Internal_Error (* cycle probably detected *)
			      | Some (fcaller, vcaller) ->
				(
				  gfct_callers <- Graph_func.G.add_edge_e gfct_callers (Graph_func.G.E.create vcaller "external" vcallee);
                                  Printf.printf "HBDBG_5\n";
                                  self#add_fct_extcaller fct_def fcaller.sign;

				  if (self#registered_as_function_callee fct_sign) &&
				    (self#registered_as_function_callee f.sign)
				  then
				    (
				      gfct_c2c <- Graph_func.G.add_edge_e gfct_c2c (Graph_func.G.E.create vcaller "external" vcallee);
				    )
				)
			      )
			    )
			  )
			)
			extcallers
		  )
		);
	      Some (fct_def, vcallee)
	    )
	)
    )

  (* method parse_json_dir (rootdir:string) : unit = *)

  (*   let jsoname_dir = String.concat "" [ rootdir; ".dir.callers.json" ] in *)
  (*   (\* let jsoname_dir = String.concat "" [ rootdir; ".dir.callers.json" ] in *\) *)
  (*   let json : Yojson.Basic.json = Common.read_json_file jsoname_dir in *)
  (*   let content : string = Yojson.Basic.to_string json in *)
  (*   Printf.printf "Read directory content is:\n %s: \n" content; *)

  (*   Printf.printf "atdgen parsed json directory is :\n"; *)
  (*   (\* Use the atdgen JSON parser *\) *)
  (*   let dir : Callers_t.dir = Callers_j.dir_of_string content in *)
  (*   print_endline (Callers_j.string_of_dir dir); *)

  (*   (\* Parse the json files contained in the current directory *\) *)
  (*   (match dir.files with *)
  (*    | None -> () *)
  (*    | Some files -> List.iter ( fun f -> self#parse_json_file f ) files *)
  (*   ) *)

  method output_function_callers (dot_filename:string) : unit =

    let file = open_out_bin dot_filename in
    Graph_func.Dot.output_graph file gfct_callers

  method output_function_callees (dot_filename:string) : unit =

    let file = open_out_bin dot_filename in
    Graph_func.Dot.output_graph file gfct_callees

  method output_function_c2c (dot_filename:string) : unit =

    let file = open_out_bin dot_filename in
    Graph_func.Dot.output_graph file gfct_c2c

end

(* Anonymous argument *)
let spec =
  let open Core.Std.Command.Spec in
  empty
  +> anon ("direction" %: string)
  +> anon ("fct1_json" %: string)
  +> anon ("fct1_id" %: string)
  +> anon ("fct1_sign" %: string)
  +> anon (maybe(sequence("other" %: string)))

(* Basic command *)
let command =
  Core.Std.Command.basic
    ~summary:"Parses function's callers and/or callees from callers's generated json files (direction=callers|callees|c2c)"
    ~readme:(fun () -> "More detailed information")
    spec
    (
      fun direction fct1_json fct1_id fct1_sign other () ->

      let parser = new function_callers_json_parser fct1_id fct1_sign fct1_json other in

      let (fct1_filepath, fct1_filename) = Batteries.String.rsplit fct1_json "/" in

      let entry_point_file : Callgraph_t.file =
        {
          name = fct1_filename;
          uses = None;
          declared = None;
          defined = None
        }
      in

      parser#complete_callgraph fct1_filepath (Some entry_point_file);

      (* let fct1_callgraph_json = Printf.sprintf "%s.fct.callgraph.gen.json" fct1_id in *)
      let fct1_callees_json = Printf.sprintf "%s.fcg.callees.gen.json" fct1_id in
      let fct1_callers_json = Printf.sprintf "%s.fcg.callers.gen.json" fct1_id in

      let fct1_callees_dot = Printf.sprintf "%s.fct.callees.gen.dot" fct1_id in
      let fct1_callers_dot = Printf.sprintf "%s.fct.callers.gen.dot" fct1_id in

      try
      (
	match direction with

	 | "callers" ->
	    (
	      let _ = parser#parse_declared_function_and_callers (fct1_sign) (fct1_json) "some_callers" None in
	      parser#output_function_callers fct1_callers_dot;
              parser#output_fcg fct1_callers_json
	    )

	 | "callees" ->
	    (
	      let _ = parser#parse_defined_function_and_callees (fct1_sign) (fct1_json) "some_callees" None in
	      parser#output_function_callees fct1_callees_dot;
              parser#output_fcg fct1_callees_json
	    )

	 | "c2c" ->
	    (match other with
	     | Some [fct2_json; fct2_id; fct2_sign; "files"]
	     | Some [fct2_json; fct2_id; fct2_sign ] ->
		(
                  let fct2_callers_json = Printf.sprintf "%s.fcg.callers.gen.json" fct2_id in
                  let fct2_callers_dot = Printf.sprintf "%s.fct.callers.gen.dot" fct2_id in

                  let fct2_c2c_json = Printf.sprintf "%s.fcg.c2c.gen.json" fct2_id in

		  Printf.printf "1) First retrieve all the callees of the caller function \"%s\ defined in file \"%s\"\n" fct1_sign fct1_json;
		  let _ = parser#parse_defined_function_and_callees (fct1_sign) (fct1_json) "some_callees" None in

		  Printf.printf "2) Then retrieve all the callers of the callee function \"%s\ declared in file \"%s\"\n" fct2_sign fct2_json;
		  let _ = parser#parse_declared_function_and_callers (fct2_sign) (fct2_json) "some_callers" None in

		  parser#output_function_callees fct1_callees_dot;
		  parser#output_function_callers fct2_callers_dot;

		  parser#output_fcg fct1_callees_json;
		  parser#output_fcg fct2_callers_json;

		  Printf.printf "3) Now we can retrieve all the paths between caller function \"%s\" and callee function \"%s\"\n" fct1_sign fct2_sign;
		  parser#output_function_c2c (Printf.sprintf "%s.%s.c2c.gen.dot" fct1_id fct2_id);
		  parser#output_fcg fct2_c2c_json
		)
	     | None
	     | _ ->
		(
		  Printf.printf "ERROR: \"c2c\" direction requires \"id\", \"sign\" and \"json\" file path of both caller fct1 and callee fct2 !\n";
		  raise Common.Usage_Error
		)
	    )
	 | _ ->
	    (
	      Printf.printf "ERROR: unsupported direction \"%s\"" direction;
	      raise Common.Internal_Error
	    )
      )
      with
	| Common.File_Not_Found -> raise Common.File_Not_Found
	(* | _ -> raise Common.Unexpected_Error *)
    )

(* Running Basic Commands *)
let () =
  Core.Std.Command.run ~version:"1.0" ~build_info:"RWO" command

(* Local Variables: *)
(* mode: tuareg *)
(* compile-command: "ocamlbuild -use-ocamlfind -package atdgen -package core -package yojson -tag thread extract_fcg.native" *)
(* compile-command: "ocamlbuild -use-ocamlfind -package atdgen -package core -package batteries -package ocamlgraph -tag thread extract_fcg.native" *)
(* End: *)
